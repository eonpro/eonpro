/**
 * SOAP Note Approval API
 *
 * POST /api/soap-notes/[id]/approve
 *
 * Allows providers to approve SOAP notes generated by admin staff.
 * Only providers can approve clinical documentation.
 *
 * HIPAA: This creates an audit trail of clinical documentation approval.
 */

import { NextRequest, NextResponse } from 'next/server';
import { withAuth, AuthUser } from '@/lib/auth/middleware';
import { prisma } from '@/lib/db';
import { logger } from '@/lib/logger';
import { auditLog, AuditEventType } from '@/lib/audit/hipaa-audit';
import { getProviderForUser } from '@/lib/auth/get-provider-for-user';
import bcrypt from 'bcryptjs';

interface RouteParams {
  params: Promise<{ id: string }>;
}

/**
 * POST /api/soap-notes/[id]/approve
 *
 * Approve a SOAP note (provider-only)
 */
export const POST = withAuth(
  async (request: NextRequest, user: AuthUser, context?: RouteParams) => {
    try {
      if (!context?.params) {
        return NextResponse.json({ error: 'Missing route parameters' }, { status: 400 });
      }
      const { id } = await context.params;
      const soapNoteId = parseInt(id, 10);

      if (isNaN(soapNoteId)) {
        return NextResponse.json({ error: 'Invalid SOAP note ID' }, { status: 400 });
      }

      // Get the SOAP note
      const soapNote = await prisma.sOAPNote.findUnique({
        where: { id: soapNoteId },
        include: {
          patient: {
            select: {
              id: true,
              firstName: true,
              lastName: true,
              clinicId: true,
            },
          },
        },
      });

      if (!soapNote) {
        return NextResponse.json({ error: 'SOAP note not found' }, { status: 404 });
      }

      // Check clinic access (unless super_admin)
      if (user.role !== 'super_admin' && soapNote.patient.clinicId !== user.clinicId) {
        return NextResponse.json(
          { error: 'Access denied - SOAP note belongs to different clinic' },
          { status: 403 }
        );
      }

      // Check if already approved
      if (soapNote.status === 'APPROVED' || soapNote.status === 'LOCKED') {
        return NextResponse.json({
          ok: true,
          message: 'SOAP note is already approved',
          soapNote: {
            id: soapNote.id,
            status: soapNote.status,
            approvedAt: soapNote.approvedAt,
            approvedBy: soapNote.approvedBy,
          },
        });
      }

      // Get provider record for the approving user (try all strategies including name match)
      const provider = await getProviderForUser(user, {
        includeClinicId: false,
        tryNameMatch: true, // Enable name matching as fallback for provider users
      });

      // Allow super_admins to approve even without a linked provider (emergency/admin override)
      const isSuperAdmin = user.role === 'super_admin';

      if (!provider && !isSuperAdmin) {
        // Log details to help debug provider linking issues
        logger.warn('[API] SOAP note approval failed - no provider found', {
          userId: user.id,
          userEmail: user.email,
          userRole: user.role,
          userClinicId: user.clinicId,
          userProviderId: user.providerId,
          soapNoteId,
        });

        // Return 400 instead of 403 to avoid triggering session expiration
        // This is a data/configuration issue, not an auth issue
        return NextResponse.json(
          {
            error:
              'Your user account is not linked to a provider profile. Please ask an administrator to link your user account to your provider record.',
            code: 'PROVIDER_NOT_FOUND',
            debug: {
              userId: user.id,
              email: user.email,
              hasProviderId: !!user.providerId,
            },
          },
          { status: 400 }
        );
      }

      // Determine approver info - use provider if available, otherwise use admin details
      const approverInfo = provider
        ? {
            id: provider.id,
            name: `${provider.firstName} ${provider.lastName}`,
            isProvider: true,
          }
        : {
            id: user.id, // Use user ID as fallback for super_admin without provider
            name: `Admin: ${user.email}`,
            isProvider: false,
          };

      // Parse request body for optional password
      let password: string | undefined;
      try {
        const body = await request.json();
        password = body.password;
      } catch {
        // No body or invalid JSON - password is optional
      }

      // Hash password if provided (for future edits)
      let passwordHash: string | undefined;
      if (password && password.length >= 8) {
        passwordHash = await bcrypt.hash(password, 10);
      }

      // Approve the SOAP note
      // For super_admin without provider, store 0 as approvedBy (system approval)
      const approvedById = approverInfo.isProvider ? approverInfo.id : 0;

      const updatedSoapNote = await prisma.sOAPNote.update({
        where: { id: soapNoteId },
        data: {
          status: 'APPROVED',
          approvedBy: approvedById,
          approvedAt: new Date(),
          ...(passwordHash && { editPasswordHash: passwordHash }),
        },
      });

      // HIPAA Audit: Log approval
      await auditLog(request, {
        userId: user.id,
        userEmail: user.email,
        userRole: user.role,
        clinicId: user.clinicId,
        eventType: AuditEventType.PHI_UPDATE,
        resourceType: 'SOAPNote',
        resourceId: soapNoteId,
        patientId: soapNote.patientId,
        action: 'APPROVE_SOAP_NOTE',
        outcome: 'SUCCESS',
        metadata: {
          previousStatus: soapNote.status,
          newStatus: 'APPROVED',
          approvedByProviderId: approverInfo.id,
          approvedByName: approverInfo.name,
          isProviderApproval: approverInfo.isProvider,
        },
      });

      logger.info('[API] SOAP note approved', {
        soapNoteId,
        patientId: soapNote.patientId,
        approvedBy: user.email,
        approverType: approverInfo.isProvider ? 'provider' : 'admin',
        approverId: approverInfo.id,
      });

      return NextResponse.json({
        ok: true,
        message: 'SOAP note approved successfully',
        soapNote: {
          id: updatedSoapNote.id,
          status: updatedSoapNote.status,
          approvedAt: updatedSoapNote.approvedAt,
          approvedBy: updatedSoapNote.approvedBy,
          approvedByProvider: {
            id: approverInfo.id,
            name: approverInfo.name,
          },
        },
      });
    } catch (error: any) {
      logger.error('[API] Error approving SOAP note:', { error: error.message });
      return NextResponse.json({ error: 'Failed to approve SOAP note' }, { status: 500 });
    }
  },
  { roles: ['super_admin', 'admin', 'provider'] } // Admins and providers can approve clinical documentation
);

/**
 * DELETE /api/soap-notes/[id]/approve
 *
 * Revoke approval (return to DRAFT) - provider only
 */
export const DELETE = withAuth(
  async (request: NextRequest, user: AuthUser, context?: RouteParams) => {
    try {
      if (!context?.params) {
        return NextResponse.json({ error: 'Missing route parameters' }, { status: 400 });
      }
      const { id } = await context.params;
      const soapNoteId = parseInt(id, 10);

      if (isNaN(soapNoteId)) {
        return NextResponse.json({ error: 'Invalid SOAP note ID' }, { status: 400 });
      }

      // Get the SOAP note
      const soapNote = await prisma.sOAPNote.findUnique({
        where: { id: soapNoteId },
        include: {
          patient: {
            select: { id: true, clinicId: true },
          },
        },
      });

      if (!soapNote) {
        return NextResponse.json({ error: 'SOAP note not found' }, { status: 404 });
      }

      // Check clinic access
      if (user.role !== 'super_admin' && soapNote.patient.clinicId !== user.clinicId) {
        return NextResponse.json({ error: 'Access denied' }, { status: 403 });
      }

      // Cannot revoke if LOCKED
      if (soapNote.status === 'LOCKED') {
        return NextResponse.json(
          { error: 'Cannot revoke approval - SOAP note is locked' },
          { status: 400 }
        );
      }

      // Revoke approval
      const updatedSoapNote = await prisma.sOAPNote.update({
        where: { id: soapNoteId },
        data: {
          status: 'DRAFT',
          approvedBy: null,
          approvedAt: null,
        },
      });

      // HIPAA Audit
      await auditLog(request, {
        userId: user.id,
        userEmail: user.email,
        userRole: user.role,
        clinicId: user.clinicId,
        eventType: AuditEventType.PHI_UPDATE,
        resourceType: 'SOAPNote',
        resourceId: soapNoteId,
        patientId: soapNote.patientId,
        action: 'REVOKE_SOAP_APPROVAL',
        outcome: 'SUCCESS',
        metadata: {
          previousStatus: soapNote.status,
          newStatus: 'DRAFT',
        },
      });

      logger.info('[API] SOAP note approval revoked', {
        soapNoteId,
        patientId: soapNote.patientId,
        revokedBy: user.email,
      });

      return NextResponse.json({
        ok: true,
        message: 'SOAP note approval revoked',
        soapNote: {
          id: updatedSoapNote.id,
          status: updatedSoapNote.status,
        },
      });
    } catch (error: any) {
      logger.error('[API] Error revoking SOAP note approval:', { error: error.message });
      return NextResponse.json({ error: 'Failed to revoke approval' }, { status: 500 });
    }
  },
  { roles: ['super_admin', 'admin', 'provider'] }
);
