generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model Patient {
  id               Int      @id @default(autoincrement())
  createdAt        DateTime @default(now())
  // REQUIRED: All patients must belong to a clinic for multi-tenant data isolation
  // Migration: Run scripts/fix-orphaned-patients.ts before deploying this change
  clinicId         Int
  clinic           Clinic   @relation(fields: [clinicId], references: [id])
  firstName        String
  lastName         String
  dob              String
  gender           String
  phone            String
  email            String
  address1         String
  city             String
  state            String
  zip              String
  lifefileId       String?
  notes            String?
  tags             Json?
  address2         String?
  patientId        String? // Unique within clinic (see @@unique below)
  stripeCustomerId String?  @unique
  source           String   @default("manual") // "webhook", "api", "manual", "referral", "import", "stripe"
  sourceMetadata   Json? // Additional source details (e.g., webhook URL, referrer ID, import batch)
  
  // Profile completion status - tracks patients auto-created from payments that need additional info
  profileStatus    ProfileStatus @default(ACTIVE)

  // Affiliate Attribution (HIPAA-safe: only used for commission tracking, not in clinical notes)
  attributionAffiliateId  Int? // The affiliate who referred this patient
  attributionAffiliate    Affiliate?                  @relation(fields: [attributionAffiliateId], references: [id])
  attributionRefCode      String? // The ref code used (e.g., "infl_xxx")
  attributionFirstTouchAt DateTime? // When the attribution was first recorded
  aiConversations         AIConversation[]
  invoices                Invoice[]
  orders                  Order[]
  auditEntries            PatientAudit[]
  documents               PatientDocument[]
  payments                Payment[]
  paymentMethods          PaymentMethod[]
  soapNotes               SOAPNote[]
  subscriptions           Subscription[]
  referrals               ReferralTracking[]
  reconciliations         PaymentReconciliation[]
  user                    User?
  intakeSubmissions       IntakeFormSubmission[]
  weightLogs              PatientWeightLog[]
  medicationReminders     PatientMedicationReminder[]
  waterLogs               PatientWaterLog[]
  exerciseLogs            PatientExerciseLog[]
  sleepLogs               PatientSleepLog[]
  nutritionLogs           PatientNutritionLog[]
  tickets                 Ticket[]
  appointments            Appointment[]
  superbills              Superbill[]
  carePlans               CarePlan[]
  smsLogs                 SmsLog[]
  discountUsages          DiscountUsage[]
  affiliateReferrals      AffiliateReferral[]
  chatMessages            PatientChatMessage[]
  shippingUpdates         PatientShippingUpdate[]
  pushSubscriptions       PushSubscription[]
  streaks                 PatientStreak[]
  achievements            PatientAchievement[]
  points                  PatientPoints?
  pointsHistory           PointsHistory[]
  challengeParticipations ChallengeParticipant[]
  refillQueue             RefillQueue[]
  telehealthSessions      TelehealthSession[]
  salesRepAssignments     PatientSalesRepAssignment[]

  @@unique([clinicId, patientId])
  @@index([clinicId])
  @@index([profileStatus]) // For efficiently querying pending profiles
}

model Order {
  id                 Int       @id @default(autoincrement())
  createdAt          DateTime  @default(now())
  clinicId           Int? // Multi-clinic support
  clinic             Clinic?   @relation(fields: [clinicId], references: [id])
  updatedAt          DateTime  @updatedAt
  messageId          String
  referenceId        String
  lifefileOrderId    String?
  status             String?
  patientId          Int
  providerId         Int
  shippingMethod     Int
  primaryMedName     String?
  primaryMedStrength String?
  primaryMedForm     String?
  errorMessage       String?
  requestJson        String?
  responseJson       String?
  lastWebhookAt      DateTime?
  lastWebhookPayload String?
  shippingStatus     String?
  trackingNumber     String?
  trackingUrl        String?

  // Cancellation tracking
  cancelledAt            DateTime? // When the order was cancelled
  cancelledBy            Int? // User ID who cancelled
  cancellationReason     String? // Reason code (patient_request, provider_request, etc.)
  cancellationNotes      String? // Additional notes about cancellation
  lifefileCancelResponse String? // JSON response from Lifefile cancel API

  // Modification tracking  
  lastModifiedAt      DateTime? // When the order was last modified
  lastModifiedBy      Int? // User ID who modified
  modificationHistory Json? // Array of modification records

  // Provider assignment tracking (for routing system)
  assignedProviderId Int? // Provider assigned via routing (may differ from providerId for queue items)
  assignedAt         DateTime? // When provider was assigned
  assignmentSource   String? // 'state_match', 'round_robin', 'manual', 'self_select', 'direct'

  provider          Provider                @relation(fields: [providerId], references: [id])
  patient           Patient                 @relation(fields: [patientId], references: [id])
  events            OrderEvent[]
  rxs               Rx[]
  tickets           Ticket[]
  shippingUpdates   PatientShippingUpdate[]
  refillAsLastOrder RefillQueue[]           @relation("RefillLastOrder")
  refillAsNewOrder  RefillQueue?            @relation("RefillNewOrder")

  // Provider Compensation
  compensationEvent ProviderCompensationEvent?

  @@index([cancelledAt])
  @@index([assignedProviderId])
}

model Rx {
  id            Int    @id @default(autoincrement())
  orderId       Int
  medicationKey String
  medName       String
  strength      String
  form          String
  quantity      String
  refills       String
  sig           String
  order         Order  @relation(fields: [orderId], references: [id])
}

model Provider {
  id        Int      @id @default(autoincrement())
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Provider status for archive/suspend functionality
  status     ProviderStatus @default(ACTIVE)
  archivedAt DateTime? // When the provider was archived
  archivedBy Int? // User ID who archived the provider

  // Legacy single clinic assignment (deprecated, use ProviderClinic)
  clinicId Int? // Multi-clinic support - nullable for shared providers
  clinic   Clinic? @relation(fields: [clinicId], references: [id])

  // ENTERPRISE: Multi-clinic support (like User.clinicId/activeClinicId pattern)
  primaryClinicId Int? // Provider's primary/default clinic
  activeClinicId  Int? // Currently active clinic for this session

  firstName            String
  lastName             String
  titleLine            String?
  npi                  String    @unique
  licenseState         String?
  licenseNumber        String?
  dea                  String?
  email                String?
  phone                String?
  signatureDataUrl     String?
  npiVerifiedAt        DateTime?
  npiRawResponse       Json?
  lastLogin            DateTime?
  user                 User?
  passwordHash         String?
  passwordResetExpires DateTime?
  passwordResetToken   String?

  // Relations
  orders              Order[]
  auditEntries        ProviderAudit[]
  approvedSoapNotes   SOAPNote[]
  intakeFormTemplates IntakeFormTemplate[]
  appointments        Appointment[]
  availability        ProviderAvailability[]
  timeOff             ProviderTimeOff[]
  superbills          Superbill[]
  carePlans           CarePlan[]

  // ENTERPRISE: Multi-clinic assignments (like UserClinic pattern)
  providerClinics ProviderClinic[]

  // ENTERPRISE: Provider Compensation System
  compensationPlans  ProviderCompensationPlan[]
  compensationEvents ProviderCompensationEvent[]

  // Telehealth & Calendar
  telehealthSessions    TelehealthSession[]
  calendarSubscriptions CalendarSubscription[]

  @@index([status])
}

model PatientDocument {
  id                 Int                     @id @default(autoincrement())
  createdAt          DateTime                @default(now())
  clinicId           Int? // Multi-clinic support
  clinic             Clinic?                 @relation(fields: [clinicId], references: [id])
  patientId          Int
  filename           String
  mimeType           String
  source             String?
  data               Bytes? // PDF binary data (or legacy JSON)
  externalUrl        String?
  sourceSubmissionId String?                 @unique
  category           PatientDocumentCategory @default(OTHER)
  patient            Patient                 @relation(fields: [patientId], references: [id])
  soapNotes          SOAPNote[]
  // Future fields (require DB migration):
  // intakeData         Json?                   // Structured intake form answers
  // pdfGeneratedAt     DateTime?               // When the PDF was generated
  // intakeVersion      String?                 // Track intake form version
}

model PatientCounter {
  id       Int    @id @default(autoincrement())
  clinicId Int    @unique // Each clinic has its own counter
  clinic   Clinic @relation(fields: [clinicId], references: [id])
  current  Int    @default(0)
}

model OrderEvent {
  id              Int      @id @default(autoincrement())
  createdAt       DateTime @default(now())
  orderId         Int
  lifefileOrderId String?
  eventType       String
  payload         Json?
  note            String?
  order           Order    @relation(fields: [orderId], references: [id])
}

model ProviderAudit {
  id         Int      @id @default(autoincrement())
  createdAt  DateTime @default(now())
  providerId Int
  actorEmail String?
  action     String
  diff       Json?
  provider   Provider @relation(fields: [providerId], references: [id])
}

model PatientAudit {
  id         Int      @id @default(autoincrement())
  createdAt  DateTime @default(now())
  patientId  Int
  actorEmail String?
  action     String
  diff       Json?
  patient    Patient  @relation(fields: [patientId], references: [id])
}

model Invoice {
  id                      Int                     @id @default(autoincrement())
  createdAt               DateTime                @default(now())
  clinicId                Int? // Multi-clinic support
  clinic                  Clinic?                 @relation(fields: [clinicId], references: [id])
  updatedAt               DateTime                @updatedAt
  stripeInvoiceId         String?                 @unique // Optional for demo mode
  stripeInvoiceNumber     String?
  stripeInvoiceUrl        String?
  stripePdfUrl            String?
  patientId               Int
  description             String?
  amount                  Int? // Total amount for demo mode
  amountDue               Int?
  amountPaid              Int                     @default(0)
  currency                String                  @default("usd")
  status                  InvoiceStatus           @default(DRAFT)
  dueDate                 DateTime?
  paidAt                  DateTime?
  lineItems               Json?
  metadata                Json?
  orderId                 Int?
  commissionGenerated     Boolean                 @default(false)
  createSubscription      Boolean                 @default(false) // If true, creates subscription on payment
  subscriptionCreated     Boolean                 @default(false) // Was subscription created?
  // Prescription processing tracking
  prescriptionProcessed   Boolean                 @default(false)
  prescriptionProcessedAt DateTime?
  prescriptionProcessedBy Int? // Provider ID who processed
  patient                 Patient                 @relation(fields: [patientId], references: [id])
  commission              Commission?
  payments                Payment[]
  items                   InvoiceItem[] // Structured line items
  reconciliations         PaymentReconciliation[]
  refillQueue             RefillQueue[]

  @@index([prescriptionProcessed])
}

model Payment {
  id                    Int           @id @default(autoincrement())
  createdAt             DateTime      @default(now())
  clinicId              Int? // Multi-clinic support
  clinic                Clinic?       @relation(fields: [clinicId], references: [id])
  stripePaymentIntentId String?       @unique
  stripeChargeId        String?
  stripeRefundId        String? // Stripe refund ID if refunded
  amount                Int
  currency              String        @default("usd")
  status                PaymentStatus @default(PENDING)
  paymentMethod         String?
  failureReason         String?
  refundedAmount        Int? // Amount refunded in cents
  refundedAt            DateTime? // When refund was processed
  paidAt                DateTime? // When payment was completed
  patientId             Int
  invoiceId             Int?
  subscriptionId        Int?
  description           String?
  notes                 String?
  metadata              Json?
  invoice               Invoice?      @relation(fields: [invoiceId], references: [id])
  patient               Patient       @relation(fields: [patientId], references: [id])
  subscription          Subscription? @relation(fields: [subscriptionId], references: [id])
}

// Audit trail for Stripe payment matching
model PaymentReconciliation {
  id        Int      @id @default(autoincrement())
  createdAt DateTime @default(now())
  clinicId  Int?
  clinic    Clinic?  @relation(fields: [clinicId], references: [id])

  // Stripe identifiers
  stripePaymentIntentId String?
  stripeChargeId        String?
  stripeInvoiceId       String?
  stripeCustomerId      String?
  stripeEventId         String? @unique // Prevent duplicate processing
  stripeEventType       String // e.g., "charge.succeeded"

  // Payment details
  amount      Int
  currency    String  @default("usd")
  description String?

  // Customer data from Stripe
  customerEmail String?
  customerName  String?
  customerPhone String?

  // Matching results
  status          ReconciliationStatus @default(PENDING)
  matchedBy       String? // "stripeCustomerId", "email", "phone", "name"
  matchConfidence String? // "exact", "high", "medium", "low"

  // Linked records (null if unmatched)
  patientId Int?
  patient   Patient? @relation(fields: [patientId], references: [id])
  invoiceId Int?
  invoice   Invoice? @relation(fields: [invoiceId], references: [id])

  // Processing details
  patientCreated Boolean   @default(false)
  processedAt    DateTime?
  errorMessage   String?
  metadata       Json? // Raw Stripe event metadata

  @@index([stripePaymentIntentId])
  @@index([stripeChargeId])
  @@index([stripeCustomerId])
  @@index([customerEmail])
  @@index([status])
  @@index([createdAt])
}

enum ReconciliationStatus {
  PENDING // Not yet processed
  MATCHED // Successfully matched to existing patient
  CREATED // New patient created
  FAILED // Processing failed
  SKIPPED // Intentionally skipped (e.g., duplicate)
}

// Profile completion status for patients created from Stripe payments
// Used to track patients that need additional information or merging
enum ProfileStatus {
  ACTIVE // Complete profile, normal patient
  PENDING_COMPLETION // Auto-created from payment with incomplete info (missing email/name)
  MERGED // Profile was merged into another patient (retained for audit)
  ARCHIVED // Soft deleted or archived
}

model PaymentMethod {
  id                    Int            @id @default(autoincrement())
  createdAt             DateTime       @default(now())
  clinicId              Int? // Multi-clinic support
  clinic                Clinic?        @relation(fields: [clinicId], references: [id])
  updatedAt             DateTime       @updatedAt
  patientId             Int
  encryptedCardNumber   String
  cardLast4             String
  cardBrand             String?
  expiryMonth           Int
  expiryYear            Int
  cardholderName        String
  encryptedCvv          String?
  billingZip            String
  stripePaymentMethodId String?        @unique
  isDefault             Boolean        @default(false)
  isActive              Boolean        @default(true)
  lastUsedAt            DateTime?
  encryptionKeyId       String
  fingerprint           String?
  patient               Patient        @relation(fields: [patientId], references: [id])
  subscriptions         Subscription[]
}

model SOAPNote {
  id                 Int                @id @default(autoincrement())
  createdAt          DateTime           @default(now())
  clinicId           Int? // Multi-clinic support
  clinic             Clinic?            @relation(fields: [clinicId], references: [id])
  updatedAt          DateTime           @updatedAt
  patientId          Int
  subjective         String
  objective          String
  assessment         String
  plan               String
  sourceType         SOAPSourceType     @default(MANUAL)
  intakeDocumentId   Int?
  generatedByAI      Boolean            @default(false)
  aiModelVersion     String?
  status             SOAPNoteStatus     @default(DRAFT)
  approvedBy         Int?
  approvedAt         DateTime?
  lockedAt           DateTime?
  editPasswordHash   String?
  promptTokens       Int?
  completionTokens   Int?
  estimatedCost      Float?
  medicalNecessity   String?
  approvedByProvider Provider?          @relation(fields: [approvedBy], references: [id])
  intakeDocument     PatientDocument?   @relation(fields: [intakeDocumentId], references: [id])
  patient            Patient            @relation(fields: [patientId], references: [id])
  revisions          SOAPNoteRevision[]

  @@index([patientId, status])
}

model SOAPNoteRevision {
  id              Int      @id @default(autoincrement())
  createdAt       DateTime @default(now())
  soapNoteId      Int
  editorEmail     String?
  editorRole      String?
  previousContent Json
  newContent      Json
  changeReason    String?
  soapNote        SOAPNote @relation(fields: [soapNoteId], references: [id])

  @@index([soapNoteId])
}

model AIConversation {
  id            Int         @id @default(autoincrement())
  createdAt     DateTime    @default(now())
  clinicId      Int? // Multi-clinic support
  clinic        Clinic?     @relation(fields: [clinicId], references: [id])
  updatedAt     DateTime    @updatedAt
  patientId     Int?
  userEmail     String
  sessionId     String
  isActive      Boolean     @default(true)
  lastMessageAt DateTime?
  patient       Patient?    @relation(fields: [patientId], references: [id])
  messages      AIMessage[]

  @@index([sessionId])
  @@index([patientId])
}

model AIMessage {
  id               Int            @id @default(autoincrement())
  createdAt        DateTime       @default(now())
  conversationId   Int
  role             String
  content          String
  queryType        String?
  citations        Json?
  confidence       Float?
  promptTokens     Int?
  completionTokens Int?
  estimatedCost    Float?
  responseTimeMs   Int?
  conversation     AIConversation @relation(fields: [conversationId], references: [id])

  @@index([conversationId])
}

model Subscription {
  id                   Int                @id @default(autoincrement())
  createdAt            DateTime           @default(now())
  clinicId             Int? // Multi-clinic support
  clinic               Clinic?            @relation(fields: [clinicId], references: [id])
  updatedAt            DateTime           @updatedAt
  patientId            Int
  planId               String
  planName             String
  planDescription      String
  status               SubscriptionStatus @default(ACTIVE)
  amount               Int
  currency             String             @default("usd")
  interval             String             @default("month")
  intervalCount        Int                @default(1)
  startDate            DateTime           @default(now())
  currentPeriodStart   DateTime           @default(now())
  currentPeriodEnd     DateTime           @default(now())
  nextBillingDate      DateTime?
  canceledAt           DateTime?
  pausedAt             DateTime?
  resumeAt             DateTime?
  endedAt              DateTime?
  paymentMethodId      Int?
  stripeSubscriptionId String?            @unique
  metadata             Json?
  lastPaymentId        Int?
  failedAttempts       Int                @default(0)

  // Refill scheduling
  vialCount          Int  @default(1) // 1 = monthly, 3 = quarterly, 6 = semi-annual
  refillIntervalDays Int? // Calculated from vialCount: 30, 90, or 180
  lastRefillQueueId  Int? // Most recent refill queue entry

  patient       Patient              @relation(fields: [patientId], references: [id])
  paymentMethod PaymentMethod?       @relation(fields: [paymentMethodId], references: [id])
  payments      Payment[]
  actions       SubscriptionAction[]
  refillQueue   RefillQueue[]

  @@index([patientId])
  @@index([status])
}

model Influencer {
  id                     Int                     @id @default(autoincrement())
  createdAt              DateTime                @default(now())
  clinicId               Int? // Multi-clinic support
  clinic                 Clinic?                 @relation(fields: [clinicId], references: [id])
  updatedAt              DateTime                @updatedAt
  email                  String                  @unique
  name                   String
  promoCode              String                  @unique
  commissionRate         Float                   @default(0.10) // 10% default commission
  status                 InfluencerStatus        @default(ACTIVE)
  passwordHash           String?
  passwordResetToken     String?
  passwordResetExpires   DateTime?
  lastLogin              DateTime?
  phone                  String?
  paypalEmail            String?
  preferredPaymentMethod String?                 @default("paypal")
  notes                  String?
  metadata               Json?
  referrals              ReferralTracking[]
  commissions            Commission[]
  payouts                CommissionPayout[]
  bankAccounts           InfluencerBankAccount[]
  user                   User?

  // New affiliate system relations
  discountCodes        DiscountCode[]
  affiliateReferrals   AffiliateReferral[]
  affiliateCommissions AffiliateCommission[]

  @@index([promoCode])
  @@index([email])
}

model InfluencerBankAccount {
  id            Int        @id @default(autoincrement())
  createdAt     DateTime   @default(now())
  updatedAt     DateTime   @updatedAt
  influencerId  Int
  bankName      String
  accountNumber String // Encrypted
  routingNumber String // Encrypted
  accountType   String     @default("checking")
  isDefault     Boolean    @default(false)
  influencer    Influencer @relation(fields: [influencerId], references: [id])

  @@index([influencerId])
}

model ReferralTracking {
  id                  Int          @id @default(autoincrement())
  createdAt           DateTime     @default(now())
  clinicId            Int? // Multi-clinic support
  clinic              Clinic?      @relation(fields: [clinicId], references: [id])
  updatedAt           DateTime     @updatedAt
  patientId           Int          @unique
  influencerId        Int
  promoCode           String
  referralSource      String? // e.g., "instagram", "youtube", "tiktok"
  referralExpiresAt   DateTime // 90 days from creation
  isConverted         Boolean      @default(false)
  convertedAt         DateTime?
  conversionInvoiceId Int?         @unique
  metadata            Json? // Store additional tracking data
  patient             Patient      @relation(fields: [patientId], references: [id])
  influencer          Influencer   @relation(fields: [influencerId], references: [id])
  commissions         Commission[]

  @@index([influencerId])
  @@index([patientId])
  @@index([referralExpiresAt])
  @@index([isConverted])
}

model Commission {
  id               Int               @id @default(autoincrement())
  createdAt        DateTime          @default(now())
  clinicId         Int? // Multi-clinic support
  clinic           Clinic?           @relation(fields: [clinicId], references: [id])
  updatedAt        DateTime          @updatedAt
  influencerId     Int
  referralId       Int
  invoiceId        Int               @unique
  orderAmount      Int // Amount in cents
  commissionRate   Float // Rate at time of commission (e.g., 0.10 for 10%)
  commissionAmount Int // Calculated commission in cents
  status           CommissionStatus  @default(PENDING)
  payoutId         Int?
  notes            String?
  metadata         Json?
  influencer       Influencer        @relation(fields: [influencerId], references: [id])
  referral         ReferralTracking  @relation(fields: [referralId], references: [id])
  invoice          Invoice           @relation(fields: [invoiceId], references: [id])
  payout           CommissionPayout? @relation(fields: [payoutId], references: [id])

  @@index([influencerId])
  @@index([status])
  @@index([payoutId])
  @@index([invoiceId])
}

model CommissionPayout {
  id              Int          @id @default(autoincrement())
  createdAt       DateTime     @default(now())
  updatedAt       DateTime     @updatedAt
  influencerId    Int
  payoutMethod    String // "paypal", "bank_transfer", "check"
  payoutReference String? // Transaction ID, check number, etc.
  totalAmount     Int // Total payout amount in cents
  currency        String       @default("usd")
  status          PayoutStatus @default(PENDING)
  paidAt          DateTime?
  failureReason   String?
  notes           String?
  metadata        Json?
  influencer      Influencer   @relation(fields: [influencerId], references: [id])
  commissions     Commission[]

  @@index([influencerId])
  @@index([status])
}

enum InfluencerStatus {
  ACTIVE
  INACTIVE
  SUSPENDED
  PENDING_APPROVAL
}

enum CommissionStatus {
  PENDING
  APPROVED
  PAID
  CANCELLED
  DISPUTED
}

enum PayoutStatus {
  PENDING
  PROCESSING
  COMPLETED
  FAILED
  CANCELLED
}

enum PatientDocumentCategory {
  MEDICAL_INTAKE_FORM
  MEDICAL_RECORDS
  LAB_RESULTS
  INSURANCE
  CONSENT_FORMS
  PRESCRIPTIONS
  IMAGING
  OTHER
}

enum WebhookStatus {
  SUCCESS
  ERROR
  INVALID_AUTH
  INVALID_PAYLOAD
  PROCESSING_ERROR
}

enum InvoiceStatus {
  DRAFT
  OPEN
  PAID
  VOID
  UNCOLLECTIBLE
  REFUNDED
  PARTIALLY_REFUNDED
}

enum PaymentStatus {
  PENDING
  PROCESSING
  SUCCEEDED
  FAILED
  CANCELED
  REFUNDED
  PARTIALLY_REFUNDED
}

enum SOAPNoteStatus {
  DRAFT
  PENDING_REVIEW
  APPROVED
  LOCKED
  ARCHIVED
}

enum SOAPSourceType {
  MANUAL
  MEDLINK_INTAKE
  AI_GENERATED
  IMPORTED
  INVOICE_METADATA
}

enum SubscriptionStatus {
  ACTIVE
  PAUSED
  CANCELED
  PAST_DUE
  EXPIRED
}

model WebhookLog {
  id               Int           @id @default(autoincrement())
  clinicId         Int? // Multi-clinic support
  clinic           Clinic?       @relation(fields: [clinicId], references: [id])
  source           String? // "stripe", "heyflow", etc.
  eventId          String? // Stripe event ID for deduplication
  eventType        String? // "payment_intent.succeeded", etc.
  endpoint         String?
  method           String?
  headers          Json?
  payload          Json?
  status           WebhookStatus
  statusCode       Int?
  errorMessage     String?
  responseData     Json?
  ipAddress        String?
  userAgent        String?
  processingTimeMs Int?
  retryCount       Int           @default(0)
  lastRetryAt      DateTime?
  processedAt      DateTime?
  metadata         Json?
  createdAt        DateTime      @default(now())

  @@unique([source, eventId])
  @@index([endpoint, createdAt(sort: Desc)])
  @@index([status, createdAt(sort: Desc)])
  @@index([createdAt(sort: Desc)])
  @@index([source, eventId])
  @@index([source, status])
}

// Unified User Management System
model User {
  id                  Int        @id @default(autoincrement())
  clinicId            Int? // Primary clinic (nullable for super admins)
  clinic              Clinic?    @relation(fields: [clinicId], references: [id])
  activeClinicId      Int? // Currently active clinic for multi-clinic users
  email               String     @unique
  phone               String? // Phone number for SMS login and notifications
  passwordHash        String
  firstName           String
  lastName            String
  role                UserRole
  status              UserStatus @default(ACTIVE)
  permissions         Json? // Custom permissions override
  features            Json? // Enabled features for this user
  metadata            Json? // Additional user metadata
  lastLogin           DateTime?
  lastPasswordChange  DateTime?
  failedLoginAttempts Int        @default(0)
  lockedUntil         DateTime?

  // Two-Factor Authentication fields
  twoFactorEnabled     Boolean   @default(false)
  twoFactorSecret      String? // Encrypted TOTP secret
  twoFactorBackupCodes Json?     @default("[]") // Hashed backup codes (stored as JSON array)
  twoFactorVerifiedAt  DateTime? // When 2FA was last verified

  // Email Verification fields
  emailVerified   Boolean   @default(false)
  emailVerifiedAt DateTime?

  createdAt               DateTime                 @default(now())
  updatedAt               DateTime                 @updatedAt
  createdById             Int?
  createdBy               User?                    @relation("UserCreatedBy", fields: [createdById], references: [id])
  createdUsers            User[]                   @relation("UserCreatedBy")
  auditLogs               UserAuditLog[]
  sessions                UserSession[]
  apiKeys                 ApiKey[]
  systemSettings          SystemSettings[]
  integrations            Integration[]
  intakeTemplates         IntakeFormTemplate[]
  passwordResetTokens     PasswordResetToken[]
  emailVerificationTokens EmailVerificationToken[]

  // Multi-clinic support
  userClinics UserClinic[] // All clinics this user belongs to

  // Relations to existing models
  providerId   Int?        @unique
  influencerId Int?        @unique
  patientId    Int?        @unique
  provider     Provider?   @relation(fields: [providerId], references: [id])
  influencer   Influencer? @relation(fields: [influencerId], references: [id])
  patient      Patient?    @relation(fields: [patientId], references: [id])

  // Affiliate Portal relation
  affiliateProfile Affiliate?

  // Internal Communication Relations
  sentMessages        InternalMessage[]     @relation("SentMessages")
  receivedMessages    InternalMessage[]     @relation("ReceivedMessages")
  ticketsCreated      Ticket[]              @relation("TicketsCreated")
  ticketsAssigned     Ticket[]              @relation("TicketsAssigned")
  ticketsResolved     Ticket[]              @relation("TicketsResolved")
  ticketsOwned        Ticket[]              @relation("TicketsOwned")
  ticketsLastWorked   Ticket[]              @relation("TicketsLastWorked")
  assignmentsMade     TicketAssignment[]    @relation("AssignmentsMade")
  assignmentsReceived TicketAssignment[]    @relation("AssignmentsReceived")
  ticketComments      TicketComment[]       @relation("TicketComments")
  statusChanges       TicketStatusHistory[] @relation("StatusChanges")
  ticketWorkLogs      TicketWorkLog[]       @relation("TicketWorkLogs")
  escalationsMade     TicketEscalation[]    @relation("EscalationsMade")
  escalationsReceived TicketEscalation[]    @relation("EscalationsReceived")
  clinicAuditLogs     ClinicAuditLog[] // Multi-clinic audit logs

  // Scheduling & Care Plan Relations
  appointmentsCreated Appointment[]      @relation("AppointmentCreatedBy")
  carePlanTemplates   CarePlanTemplate[]
  carePlanProgress    CarePlanProgress[]

  // Financial Analytics Relations
  savedReports  SavedReport[]
  reportExports ReportExport[]

  // SOC 2 Policy Management Relations
  policyApprovals       PolicyApproval[]
  policyAcknowledgments PolicyAcknowledgment[]

  // Sales Rep Assignment Relations
  salesRepAssignments   PatientSalesRepAssignment[] @relation("SalesRepAssignments")
  assignmentsMadeByUser PatientSalesRepAssignment[] @relation("AssignmentsMadeBy")
  assignmentsRemovedBy  PatientSalesRepAssignment[] @relation("AssignmentsRemovedBy")

  // In-App Notifications
  notifications Notification[]

  @@index([email])
  @@index([role, status])
  @@index([createdAt(sort: Desc)])
  @@index([clinicId])
  @@index([activeClinicId])
}

// Junction table for users belonging to multiple clinics
model UserClinic {
  id        Int      @id @default(autoincrement())
  userId    Int
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  clinicId  Int
  clinic    Clinic   @relation(fields: [clinicId], references: [id], onDelete: Cascade)
  role      UserRole // Role can be different per clinic
  isPrimary Boolean  @default(false) // Is this the user's primary clinic?
  isActive  Boolean  @default(true) // Is this assignment active?
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@unique([userId, clinicId]) // User can only be assigned once per clinic
  @@index([userId])
  @@index([clinicId])
}

// Sales Rep Patient Assignment - Tracks which sales rep is assigned to which patient
// Maintains history of assignments for audit trail and bulk reassignment
model PatientSalesRepAssignment {
  id         Int @id @default(autoincrement())
  patientId  Int
  salesRepId Int // User ID with SALES_REP role
  clinicId   Int // Multi-tenant isolation

  // Assignment tracking
  assignedAt   DateTime @default(now())
  assignedById Int? // Admin who made assignment

  // Removal tracking (for history)
  removedAt   DateTime?
  removedById Int? // Admin who removed assignment
  removalNote String? // Reason for reassignment

  isActive Boolean @default(true)

  // Relations
  patient    Patient @relation(fields: [patientId], references: [id], onDelete: Cascade)
  salesRep   User    @relation("SalesRepAssignments", fields: [salesRepId], references: [id])
  clinic     Clinic  @relation(fields: [clinicId], references: [id])
  assignedBy User?   @relation("AssignmentsMadeBy", fields: [assignedById], references: [id])
  removedBy  User?   @relation("AssignmentsRemovedBy", fields: [removedById], references: [id])

  @@index([salesRepId, clinicId, isActive])
  @@index([patientId, isActive])
  @@index([clinicId])
}

// ENTERPRISE: Junction table for providers belonging to multiple clinics
// Mirrors UserClinic pattern for consistent multi-tenant architecture
model ProviderClinic {
  id         Int      @id @default(autoincrement())
  providerId Int
  provider   Provider @relation(fields: [providerId], references: [id], onDelete: Cascade)
  clinicId   Int
  clinic     Clinic   @relation(fields: [clinicId], references: [id], onDelete: Cascade)

  // Per-clinic provider metadata
  isPrimary     Boolean @default(false) // Is this the provider's primary clinic?
  isActive      Boolean @default(true) // Is this assignment active?
  titleLine     String? // Clinic-specific title (e.g., different role per clinic)
  deaNumber     String? // State/clinic-specific DEA number
  licenseNumber String? // State-specific license number
  licenseState  String? // State of license for this clinic

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@unique([providerId, clinicId]) // Provider can only be assigned once per clinic
  @@index([providerId])
  @@index([clinicId])
  @@index([isActive])
}

model UserSession {
  id           Int      @id @default(autoincrement())
  userId       Int
  user         User     @relation(fields: [userId], references: [id])
  token        String   @unique
  refreshToken String   @unique
  ipAddress    String?
  userAgent    String?
  expiresAt    DateTime
  createdAt    DateTime @default(now())
  lastActivity DateTime @default(now())

  @@index([token])
  @@index([userId, expiresAt])
}

model UserAuditLog {
  id        Int      @id @default(autoincrement())
  userId    Int
  user      User     @relation(fields: [userId], references: [id])
  action    String // LOGIN, LOGOUT, PASSWORD_CHANGE, PERMISSION_CHANGE, etc.
  details   Json?
  ipAddress String?
  userAgent String?
  createdAt DateTime @default(now())

  @@index([userId, createdAt(sort: Desc)])
  @@index([action, createdAt(sort: Desc)])
}

// General audit log for all system activities (HIPAA compliance)
model AuditLog {
  id         Int      @id @default(autoincrement())
  userId     Int
  action     String // TWO_FACTOR_ENABLED, PHI_ACCESS, PRESCRIPTION_CREATED, etc.
  resource   String? // Resource type (Patient, Order, etc.)
  resourceId Int? // ID of the resource
  details    Json? // Additional audit details
  ipAddress  String?
  userAgent  String?
  clinicId   Int?
  createdAt  DateTime @default(now())

  @@index([userId, createdAt(sort: Desc)])
  @@index([action, createdAt(sort: Desc)])
  @@index([resource, resourceId])
}

// HIPAA-Compliant Audit Entry - Comprehensive PHI access logging
// Designed to meet HIPAA ยง164.312(b) audit control requirements
model HIPAAAuditEntry {
  id        Int      @id @default(autoincrement())
  createdAt DateTime @default(now())

  // User context - who performed the action
  userId    String // String to handle system/anonymous
  userEmail String
  userRole  String
  clinicId  Int?

  // Event classification
  eventType    String // PHI_VIEW, PHI_UPDATE, LOGIN, etc.
  resourceType String // Patient, Order, SOAPNote, etc.
  resourceId   String? // ID of accessed resource
  patientId    Int? // Patient whose data was accessed (for PHI events)

  // Request context - forensic data
  ipAddress     String
  userAgent     String
  sessionId     String?
  requestId     String // Unique request identifier
  requestMethod String // GET, POST, PUT, DELETE
  requestPath   String // API path accessed

  // Outcome tracking
  outcome String // SUCCESS, FAILURE, PARTIAL
  reason  String? // Failure reason if applicable

  // Integrity verification (tamper detection)
  hash String // SHA-256 hash of record for integrity

  // Additional context
  metadata  Json? // Flexible additional data
  emergency Boolean @default(false) // Break-glass access

  // Indexes for efficient querying (HIPAA requires searchable audit logs)
  @@index([userId, createdAt(sort: Desc)])
  @@index([eventType, createdAt(sort: Desc)])
  @@index([patientId, createdAt(sort: Desc)])
  @@index([clinicId, createdAt(sort: Desc)])
  @@index([resourceType, resourceId])
  @@index([createdAt(sort: Desc)])
  @@index([outcome, createdAt(sort: Desc)])
  @@index([requestId])
}

// Password Reset Token
model PasswordResetToken {
  id        Int       @id @default(autoincrement())
  userId    Int
  user      User      @relation(fields: [userId], references: [id])
  token     String    @unique // Hashed token
  expiresAt DateTime
  used      Boolean   @default(false)
  usedAt    DateTime?
  ipAddress String?
  createdAt DateTime  @default(now())

  @@index([token])
  @@index([userId, expiresAt])
}

// Email verification tokens for patient self-registration
model EmailVerificationToken {
  id        Int       @id @default(autoincrement())
  userId    Int
  user      User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  token     String    @unique // Hashed token (SHA-256)
  expiresAt DateTime
  used      Boolean   @default(false)
  usedAt    DateTime?
  createdAt DateTime  @default(now())

  @@index([token])
  @@index([userId])
}

// Clinic invite codes for patient self-registration
model ClinicInviteCode {
  id          Int       @id @default(autoincrement())
  clinicId    Int
  clinic      Clinic    @relation(fields: [clinicId], references: [id])
  code        String    @unique // e.g., "CLINIC123" (uppercase, alphanumeric)
  description String? // e.g., "Website registration", "Marketing campaign"
  usageLimit  Int? // null = unlimited
  usageCount  Int       @default(0)
  expiresAt   DateTime?
  isActive    Boolean   @default(true)
  createdAt   DateTime  @default(now())
  createdById Int?

  @@index([code])
  @@index([clinicId])
}

// Phone OTP for SMS-based authentication
model PhoneOtp {
  id        Int       @id @default(autoincrement())
  phone     String // Formatted phone number
  code      String // 6-digit OTP code
  expiresAt DateTime
  used      Boolean   @default(false)
  usedAt    DateTime?
  userId    Int? // If associated with a User
  patientId Int? // If associated with a Patient
  ipAddress String?
  createdAt DateTime  @default(now())

  @@index([phone, code, expiresAt])
  @@index([phone])
}

enum UserRole {
  SUPER_ADMIN
  ADMIN
  PROVIDER
  INFLUENCER
  AFFILIATE
  PATIENT
  STAFF
  SUPPORT
  SALES_REP
}

enum UserStatus {
  ACTIVE
  INACTIVE
  SUSPENDED
  PENDING_VERIFICATION
  LOCKED
}

enum ProviderStatus {
  ACTIVE
  ARCHIVED
  SUSPENDED
}

// Settings & Configuration System
model SystemSettings {
  id          Int      @id @default(autoincrement())
  clinicId    Int? // Multi-clinic support (null for global settings)
  clinic      Clinic?  @relation(fields: [clinicId], references: [id])
  category    String // general, security, integrations, notifications, etc.
  key         String
  value       Json
  description String?
  isPublic    Boolean  @default(false) // Can be exposed to non-admins
  isEncrypted Boolean  @default(false) // Should be encrypted at rest
  updatedAt   DateTime @updatedAt
  updatedById Int?
  updatedBy   User?    @relation(fields: [updatedById], references: [id])

  @@unique([category, key])
  @@index([category])
}

model Integration {
  id          Int               @id @default(autoincrement())
  clinicId    Int? // Multi-clinic support
  clinic      Clinic?           @relation(fields: [clinicId], references: [id])
  name        String            @unique
  provider    String // stripe, lifefile, twilio, sendgrid, etc.
  status      IntegrationStatus @default(INACTIVE)
  config      Json // Encrypted configuration
  credentials Json? // Encrypted credentials
  webhookUrl  String?
  lastSyncAt  DateTime?
  errorCount  Int               @default(0)
  lastError   String?
  metadata    Json?
  createdAt   DateTime          @default(now())
  updatedAt   DateTime          @updatedAt
  createdById Int?
  createdBy   User?             @relation(fields: [createdById], references: [id])
  apiKeys     ApiKey[]
  webhooks    WebhookConfig[]
  logs        IntegrationLog[]

  @@index([provider, status])
}

model ApiKey {
  id            Int           @id @default(autoincrement())
  clinicId      Int? // Multi-clinic support
  clinic        Clinic?       @relation(fields: [clinicId], references: [id])
  name          String
  key           String        @unique
  hashedKey     String // Store hashed version for security
  prefix        String // First 7 chars for identification
  permissions   Json // Specific permissions for this key
  rateLimit     Int           @default(1000) // Requests per hour
  expiresAt     DateTime?
  lastUsedAt    DateTime?
  lastUsedIp    String?
  status        ApiKeyStatus  @default(ACTIVE)
  integrationId Int?
  integration   Integration?  @relation(fields: [integrationId], references: [id])
  userId        Int
  user          User          @relation(fields: [userId], references: [id])
  createdAt     DateTime      @default(now())
  usageLogs     ApiUsageLog[]

  @@index([key])
  @@index([userId])
  @@index([status])
}

model ApiUsageLog {
  id           Int      @id @default(autoincrement())
  apiKeyId     Int
  apiKey       ApiKey   @relation(fields: [apiKeyId], references: [id])
  endpoint     String
  method       String
  statusCode   Int
  responseTime Int // in milliseconds
  ipAddress    String
  userAgent    String?
  requestBody  Json?
  responseBody Json?
  createdAt    DateTime @default(now())

  @@index([apiKeyId, createdAt(sort: Desc)])
  @@index([endpoint, createdAt(sort: Desc)])
}

model WebhookConfig {
  id            Int               @id @default(autoincrement())
  clinicId      Int? // Multi-clinic support
  clinic        Clinic?           @relation(fields: [clinicId], references: [id])
  name          String
  url           String
  events        Json // Array of event types to trigger
  headers       Json? // Custom headers
  secret        String? // For webhook signature verification
  isActive      Boolean           @default(true)
  retryPolicy   Json? // Retry configuration
  integrationId Int?
  integration   Integration?      @relation(fields: [integrationId], references: [id])
  createdAt     DateTime          @default(now())
  updatedAt     DateTime          @updatedAt
  deliveries    WebhookDelivery[]

  @@index([isActive])
}

model WebhookDelivery {
  id          Int                   @id @default(autoincrement())
  webhookId   Int
  webhook     WebhookConfig         @relation(fields: [webhookId], references: [id])
  event       String
  payload     Json
  status      WebhookDeliveryStatus
  attempts    Int                   @default(1)
  statusCode  Int?
  response    Json?
  error       String?
  deliveredAt DateTime?
  createdAt   DateTime              @default(now())

  @@index([webhookId, status])
  @@index([createdAt(sort: Desc)])
}

model IntegrationLog {
  id            Int         @id @default(autoincrement())
  integrationId Int
  integration   Integration @relation(fields: [integrationId], references: [id])
  action        String // sync, webhook_received, api_call, etc.
  status        String // success, error, warning
  message       String
  details       Json?
  createdAt     DateTime    @default(now())

  @@index([integrationId, createdAt(sort: Desc)])
  @@index([status, createdAt(sort: Desc)])
}

model DeveloperTool {
  id           Int       @id @default(autoincrement())
  name         String    @unique
  category     String // database, cache, queue, monitoring, etc.
  status       String // enabled, disabled, error
  config       Json
  lastCheckAt  DateTime?
  healthStatus Json? // Latest health check results
  createdAt    DateTime  @default(now())
  updatedAt    DateTime  @updatedAt

  @@index([category])
}

enum IntegrationStatus {
  ACTIVE
  INACTIVE
  ERROR
  MAINTENANCE
}

enum ApiKeyStatus {
  ACTIVE
  INACTIVE
  EXPIRED
  REVOKED
}

enum WebhookDeliveryStatus {
  PENDING
  DELIVERED
  FAILED
  RETRYING
}

// ===== INTAKE FORM SYSTEM =====

model IntakeFormTemplate {
  id               Int                     @id @default(autoincrement())
  createdAt        DateTime                @default(now())
  clinicId         Int? // Multi-clinic support
  clinic           Clinic?                 @relation(fields: [clinicId], references: [id])
  updatedAt        DateTime                @updatedAt
  name             String // e.g., "General Medical Intake", "Weight Loss Program Intake"
  description      String?
  treatmentType    String // e.g., "general", "weight-loss", "hormone-therapy", "aesthetic"
  isActive         Boolean                 @default(true)
  providerId       Int? // Optional: specific provider's form
  provider         Provider?               @relation(fields: [providerId], references: [id])
  createdById      Int? // User who created this template
  createdBy        User?                   @relation(fields: [createdById], references: [id])
  questions        IntakeFormQuestion[]
  submissions      IntakeFormSubmission[]
  formLinks        IntakeFormLink[]
  version          Int                     @default(1)
  metadata         Json? // Additional settings, styling, etc.
  appointmentTypes AppointmentTypeConfig[]

  @@index([treatmentType, isActive])
  @@index([providerId])
  @@index([createdById])
}

model IntakeFormQuestion {
  id               Int                  @id @default(autoincrement())
  createdAt        DateTime             @default(now())
  templateId       Int
  template         IntakeFormTemplate   @relation(fields: [templateId], references: [id], onDelete: Cascade)
  questionText     String
  questionType     String // "text", "textarea", "select", "radio", "checkbox", "date", "number", "email", "phone", "signature", "file"
  options          Json? // For select/radio/checkbox: ["Option 1", "Option 2"]
  isRequired       Boolean              @default(false)
  validation       Json? // { "min": 0, "max": 100, "pattern": "regex" }
  placeholder      String?
  helpText         String?
  orderIndex       Int                  @default(0)
  section          String? // Group questions into sections
  conditionalLogic Json? // Show/hide based on other answers
  responses        IntakeFormResponse[]

  @@index([templateId, orderIndex])
}

model IntakeFormSubmission {
  id             Int                  @id @default(autoincrement())
  createdAt      DateTime             @default(now())
  updatedAt      DateTime             @updatedAt
  templateId     Int
  template       IntakeFormTemplate   @relation(fields: [templateId], references: [id])
  patientId      Int
  patient        Patient              @relation(fields: [patientId], references: [id])
  status         String               @default("pending") // "pending", "in_progress", "completed", "expired"
  completedAt    DateTime?
  formLinkId     String?              @unique
  formLink       IntakeFormLink?      @relation(fields: [formLinkId], references: [id])
  responses      IntakeFormResponse[]
  pdfUrl         String? // URL to generated PDF
  pdfGeneratedAt DateTime?
  metadata       Json? // IP address, device info, etc.
  signature      String? // Base64 signature image
  signedAt       DateTime?

  @@index([patientId, status])
  @@index([templateId])
}

model IntakeFormResponse {
  id           Int                  @id @default(autoincrement())
  createdAt    DateTime             @default(now())
  submissionId Int
  submission   IntakeFormSubmission @relation(fields: [submissionId], references: [id], onDelete: Cascade)
  questionId   Int
  question     IntakeFormQuestion   @relation(fields: [questionId], references: [id])
  answer       String? // Text answer or JSON for complex types
  fileUrl      String? // For file uploads

  @@unique([submissionId, questionId])
  @@index([submissionId])
}

model IntakeFormLink {
  id           String                @id @default(cuid())
  createdAt    DateTime              @default(now())
  expiresAt    DateTime
  templateId   Int
  template     IntakeFormTemplate    @relation(fields: [templateId], references: [id])
  patientEmail String
  patientPhone String?
  sentVia      String? // "email", "sms", "both"
  sentAt       DateTime?
  clickedAt    DateTime?
  submission   IntakeFormSubmission?
  isActive     Boolean               @default(true)
  metadata     Json? // Tracking info, utm params, etc.

  @@index([patientEmail, isActive])
  @@index([expiresAt])
}

// ===== PATIENT PROGRESS TRACKING =====

model PatientWeightLog {
  id         Int      @id @default(autoincrement())
  createdAt  DateTime @default(now())
  patientId  Int
  patient    Patient  @relation(fields: [patientId], references: [id])
  weight     Float // Weight in pounds
  unit       String   @default("lbs") // "lbs" or "kg"
  notes      String? // Optional notes from patient
  source     String   @default("patient") // "patient", "provider", "import"
  recordedAt DateTime @default(now()) // When the measurement was taken

  @@index([patientId, recordedAt])
}

model PatientMedicationReminder {
  id             Int       @id @default(autoincrement())
  createdAt      DateTime  @default(now())
  updatedAt      DateTime  @updatedAt
  patientId      Int
  patient        Patient   @relation(fields: [patientId], references: [id])
  medicationName String // e.g., "Semaglutide 0.5mg"
  dayOfWeek      Int // 0=Sunday, 1=Monday, etc.
  timeOfDay      String    @default("08:00") // HH:MM format
  isActive       Boolean   @default(true)
  lastTriggered  DateTime? // Last time reminder was sent
  metadata       Json? // Additional reminder settings

  @@unique([patientId, medicationName, dayOfWeek]) // One reminder per medication per day
  @@index([patientId, isActive])
}

model PatientWaterLog {
  id         Int      @id @default(autoincrement())
  createdAt  DateTime @default(now())
  clinicId   Int?
  clinic     Clinic?  @relation(fields: [clinicId], references: [id])
  patientId  Int
  patient    Patient  @relation(fields: [patientId], references: [id])
  amount     Float // Amount in ounces
  unit       String   @default("oz") // "oz" or "ml"
  source     String   @default("patient") // "patient", "device", "import"
  recordedAt DateTime @default(now())
  notes      String?

  @@index([patientId, recordedAt])
  @@index([clinicId])
}

model PatientExerciseLog {
  id           Int      @id @default(autoincrement())
  createdAt    DateTime @default(now())
  clinicId     Int?
  clinic       Clinic?  @relation(fields: [clinicId], references: [id])
  patientId    Int
  patient      Patient  @relation(fields: [patientId], references: [id])
  activityType String // "walking", "running", "cycling", "strength", "yoga", etc.
  duration     Int // Duration in minutes
  intensity    String   @default("moderate") // "light", "moderate", "vigorous"
  calories     Int? // Estimated calories burned
  steps        Int? // Step count if applicable
  distance     Float? // Distance in miles
  heartRateAvg Int? // Average heart rate
  notes        String?
  source       String   @default("patient") // "patient", "device", "import"
  recordedAt   DateTime @default(now())

  @@index([patientId, recordedAt])
  @@index([clinicId])
}

model PatientSleepLog {
  id         Int      @id @default(autoincrement())
  createdAt  DateTime @default(now())
  clinicId   Int?
  clinic     Clinic?  @relation(fields: [clinicId], references: [id])
  patientId  Int
  patient    Patient  @relation(fields: [patientId], references: [id])
  sleepStart DateTime // When they went to bed
  sleepEnd   DateTime // When they woke up
  duration   Int // Total sleep duration in minutes
  quality    Int? // Sleep quality rating 1-10
  deepSleep  Int? // Deep sleep minutes
  remSleep   Int? // REM sleep minutes
  lightSleep Int? // Light sleep minutes
  awakeTime  Int? // Time awake during sleep in minutes
  notes      String?
  source     String   @default("patient") // "patient", "device", "import"
  recordedAt DateTime @default(now())

  @@index([patientId, recordedAt])
  @@index([clinicId])
}

model PatientNutritionLog {
  id          Int      @id @default(autoincrement())
  createdAt   DateTime @default(now())
  clinicId    Int?
  clinic      Clinic?  @relation(fields: [clinicId], references: [id])
  patientId   Int
  patient     Patient  @relation(fields: [patientId], references: [id])
  mealType    String // "breakfast", "lunch", "dinner", "snack"
  description String? // What they ate
  calories    Int? // Total calories
  protein     Float? // Grams of protein
  carbs       Float? // Grams of carbohydrates
  fat         Float? // Grams of fat
  fiber       Float? // Grams of fiber
  sugar       Float? // Grams of sugar
  sodium      Float? // Milligrams of sodium
  photoUrl    String? // Optional photo of meal
  notes       String?
  source      String   @default("patient") // "patient", "import"
  recordedAt  DateTime @default(now())

  @@index([patientId, recordedAt])
  @@index([clinicId])
}

// ===== INTERNAL COMMUNICATION SYSTEM =====

model InternalMessage {
  id              Int                 @id @default(autoincrement())
  createdAt       DateTime            @default(now())
  clinicId        Int? // Multi-clinic support
  clinic          Clinic?             @relation(fields: [clinicId], references: [id])
  senderId        Int
  sender          User                @relation("SentMessages", fields: [senderId], references: [id])
  recipientId     Int? // Null for broadcast messages
  recipient       User?               @relation("ReceivedMessages", fields: [recipientId], references: [id])
  message         String
  isRead          Boolean             @default(false)
  readAt          DateTime?
  attachments     Json? // File URLs/references
  messageType     InternalMessageType @default(DIRECT)
  channelId       String? // For channel/group messages
  parentMessageId Int? // For threaded replies
  parentMessage   InternalMessage?    @relation("MessageThread", fields: [parentMessageId], references: [id])
  replies         InternalMessage[]   @relation("MessageThread")
  metadata        Json? // Additional context

  @@index([senderId, createdAt])
  @@index([recipientId, isRead])
  @@index([channelId, createdAt])
}

model Ticket {
  id           Int                @id @default(autoincrement())
  createdAt    DateTime           @default(now())
  clinicId     Int? // Multi-clinic support
  clinic       Clinic?            @relation(fields: [clinicId], references: [id])
  updatedAt    DateTime           @updatedAt
  ticketNumber String             @unique @default("")
  title        String
  description  String
  priority     TicketPriority     @default(MEDIUM)
  status       TicketStatus       @default(OPEN)
  disposition  TicketDisposition?
  category     TicketCategory     @default(GENERAL)

  // Related entities
  patientId        Int?
  patient          Patient? @relation(fields: [patientId], references: [id])
  orderId          Int?
  order            Order?   @relation(fields: [orderId], references: [id])
  isNonClientIssue Boolean  @default(false)

  // People involved
  createdById  Int
  createdBy    User  @relation("TicketsCreated", fields: [createdById], references: [id])
  assignedToId Int?
  assignedTo   User? @relation("TicketsAssigned", fields: [assignedToId], references: [id])

  // Activity tracking
  assignments   TicketAssignment[]
  comments      TicketComment[]
  statusHistory TicketStatusHistory[]
  workLogs      TicketWorkLog[]
  escalations   TicketEscalation[]
  sla           TicketSLA?

  // Ownership tracking
  currentOwnerId Int?
  currentOwner   User?     @relation("TicketsOwned", fields: [currentOwnerId], references: [id])
  lastWorkedById Int?
  lastWorkedBy   User?     @relation("TicketsLastWorked", fields: [lastWorkedById], references: [id])
  lastWorkedAt   DateTime?

  // Resolution
  resolvedAt      DateTime?
  resolvedById    Int?
  resolvedBy      User?     @relation("TicketsResolved", fields: [resolvedById], references: [id])
  resolutionNotes String?
  resolutionTime  Int? // Total time to resolution in minutes
  actualWorkTime  Int? // Actual time worked in minutes

  // Additional data
  tags         Json? // Array of tags
  customFields Json? // Custom field values
  attachments  Json? // File references

  @@index([status, priority, createdAt])
  @@index([assignedToId, status])
  @@index([patientId])
  @@index([ticketNumber])
}

model TicketAssignment {
  id           Int      @id @default(autoincrement())
  createdAt    DateTime @default(now())
  ticketId     Int
  ticket       Ticket   @relation(fields: [ticketId], references: [id])
  assignedById Int
  assignedBy   User     @relation("AssignmentsMade", fields: [assignedById], references: [id])
  assignedToId Int
  assignedTo   User     @relation("AssignmentsReceived", fields: [assignedToId], references: [id])
  notes        String?

  @@index([ticketId])
  @@index([assignedToId])
}

model TicketComment {
  id          Int      @id @default(autoincrement())
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  ticketId    Int
  ticket      Ticket   @relation(fields: [ticketId], references: [id])
  authorId    Int
  author      User     @relation("TicketComments", fields: [authorId], references: [id])
  comment     String
  isInternal  Boolean  @default(false) // Internal notes vs customer-visible
  attachments Json? // File references

  @@index([ticketId, createdAt])
}

model TicketStatusHistory {
  id          Int          @id @default(autoincrement())
  createdAt   DateTime     @default(now())
  ticketId    Int
  ticket      Ticket       @relation(fields: [ticketId], references: [id])
  fromStatus  TicketStatus
  toStatus    TicketStatus
  changedById Int
  changedBy   User         @relation("StatusChanges", fields: [changedById], references: [id])
  reason      String?

  @@index([ticketId, createdAt])
}

model TicketWorkLog {
  id          Int          @id @default(autoincrement())
  createdAt   DateTime     @default(now())
  ticketId    Int
  ticket      Ticket       @relation(fields: [ticketId], references: [id])
  userId      Int
  user        User         @relation("TicketWorkLogs", fields: [userId], references: [id])
  action      TicketAction
  duration    Int? // Duration in minutes
  description String
  isInternal  Boolean      @default(true)
  metadata    Json? // Additional action-specific data

  @@index([ticketId, createdAt])
  @@index([userId, createdAt])
}

model TicketEscalation {
  id            Int       @id @default(autoincrement())
  createdAt     DateTime  @default(now())
  ticketId      Int
  ticket        Ticket    @relation(fields: [ticketId], references: [id])
  escalatedById Int
  escalatedBy   User      @relation("EscalationsMade", fields: [escalatedById], references: [id])
  escalatedToId Int
  escalatedTo   User      @relation("EscalationsReceived", fields: [escalatedToId], references: [id])
  level         Int       @default(1) // Escalation level (1, 2, 3, etc.)
  reason        String
  isActive      Boolean   @default(true)
  resolvedAt    DateTime?

  @@index([ticketId, isActive])
}

model TicketSLA {
  id               Int       @id @default(autoincrement())
  createdAt        DateTime  @default(now())
  ticketId         Int       @unique
  ticket           Ticket    @relation(fields: [ticketId], references: [id])
  firstResponseDue DateTime? // When first response is due
  firstResponseAt  DateTime? // When first response occurred
  resolutionDue    DateTime // When resolution is due
  resolvedAt       DateTime? // When actually resolved
  breached         Boolean   @default(false)
  breachReason     String?

  @@index([resolutionDue, breached])
}

// Enums for Internal Communication

enum InternalMessageType {
  DIRECT // One-to-one message
  BROADCAST // System-wide announcement
  CHANNEL // Channel/group message
  ALERT // Urgent notification
}

enum TicketPriority {
  LOW
  MEDIUM
  HIGH
  URGENT
}

enum TicketStatus {
  OPEN
  IN_PROGRESS
  PENDING
  ON_HOLD
  ESCALATED
  RESOLVED
  CLOSED
  CANCELLED
}

enum TicketDisposition {
  RESOLVED_SUCCESSFULLY
  RESOLVED_WITH_WORKAROUND
  NOT_RESOLVED
  DUPLICATE
  NOT_REPRODUCIBLE
  BY_DESIGN
  CUSTOMER_ERROR
  TRAINING_ISSUE
  REFERRED_TO_SPECIALIST
  PENDING_CUSTOMER
  CANCELLED_BY_CUSTOMER
}

enum TicketCategory {
  GENERAL
  BILLING
  PRESCRIPTION
  APPOINTMENT
  TECHNICAL_ISSUE
  MEDICATION_QUESTION
  INSURANCE
  DELIVERY
  SIDE_EFFECTS
  DOSAGE
  REFILL
  PORTAL_ACCESS
  OTHER
}

enum TicketAction {
  CREATED
  ASSIGNED
  REASSIGNED
  STARTED_WORK
  STOPPED_WORK
  ADDED_COMMENT
  UPDATED_STATUS
  ESCALATED
  DE_ESCALATED
  REQUESTED_INFO
  PROVIDED_INFO
  RESEARCHED
  CONTACTED_PATIENT
  CONTACTED_PROVIDER
  CONTACTED_PHARMACY
  CONTACTED_INSURANCE
  APPLIED_SOLUTION
  TESTED_SOLUTION
  RESOLVED
  REOPENED
  CLOSED
  MERGED
  SPLIT
}

// ===== MULTI-CLINIC SUPPORT =====

model Clinic {
  id        Int      @id @default(autoincrement())
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Basic Information
  name         String
  subdomain    String       @unique
  customDomain String?      @unique
  status       ClinicStatus @default(ACTIVE)

  // Configuration
  settings        Json // UI settings, themes, branding
  features        Json // Enabled features per clinic
  integrations    Json // API keys, webhooks per clinic
  patientIdPrefix String? // e.g., "EON", "WEL", "OT" - prefix for patient IDs

  // Stripe Connect Integration
  stripeAccountId          String?   @unique // Connected account ID (acct_xxx)
  stripeAccountStatus      String? // 'pending', 'active', 'restricted', 'rejected'
  stripeOnboardingComplete Boolean   @default(false) // Has completed Stripe onboarding
  stripeChargesEnabled     Boolean   @default(false) // Can accept charges
  stripePayoutsEnabled     Boolean   @default(false) // Can receive payouts
  stripeDetailsSubmitted   Boolean   @default(false) // Has submitted account details
  stripePlatformAccount    Boolean   @default(false) // Is this the platform account (EONmeds)?
  stripeConnectedAt        DateTime? // When they connected their Stripe account

  // Lifefile Integration (per-clinic credentials - encrypted)
  lifefileBaseUrl          String? // API base URL
  lifefileUsername         String? // API username (encrypted)
  lifefilePassword         String? // API password (encrypted)
  lifefileVendorId         String? // Vendor ID
  lifefilePracticeId       String? // Practice ID
  lifefileLocationId       String? // Location ID (e.g., 110396 for logospharmacy)
  lifefileNetworkId        String? // Network ID
  lifefilePracticeName     String? // Practice name for prescriptions
  lifefilePracticeAddress  String? // Practice address
  lifefilePracticePhone    String? // Practice phone
  lifefilePracticeFax      String? // Practice fax
  lifefileWebhookSecret    String? // Webhook verification secret
  lifefileDatapushUsername String? // Data push webhook username
  lifefileDatapushPassword String? // Data push webhook password (encrypted)
  lifefileEnabled          Boolean @default(false) // Is Lifefile integration enabled?

  // Zoom Telehealth Integration (per-clinic OAuth)
  zoomAccountId          String?   @unique // Zoom account ID
  zoomAccountEmail       String? // Zoom account email
  zoomClientId           String? // OAuth client ID (encrypted)
  zoomClientSecret       String? // OAuth client secret (encrypted)
  zoomAccessToken        String? // OAuth access token (encrypted)
  zoomRefreshToken       String? // OAuth refresh token (encrypted)
  zoomTokenExpiresAt     DateTime? // When access token expires
  zoomWebhookSecret      String? // Webhook verification secret
  zoomSdkKey             String? // Web SDK key (for client-side)
  zoomSdkSecret          String? // Web SDK secret (encrypted)
  zoomEnabled            Boolean   @default(false) // Is Zoom integration enabled?
  zoomOnboardingComplete Boolean   @default(false) // Has completed Zoom OAuth
  zoomConnectedAt        DateTime? // When they connected Zoom
  zoomWaitingRoomEnabled Boolean   @default(true) // Enable waiting room by default
  zoomRecordingEnabled   Boolean   @default(true) // Enable cloud recording
  zoomHipaaCompliant     Boolean   @default(true) // Use HIPAA-compliant settings

  // Billing & Limits
  billingPlan   String @default("starter")
  patientLimit  Int    @default(100)
  providerLimit Int    @default(5)
  storageLimit  Int    @default(5000) // MB

  // Contact Information
  adminEmail   String
  supportEmail String?
  phone        String?
  address      Json? // {address1, address2, city, state, zip, country}
  timezone     String  @default("America/New_York")

  // Branding
  logoUrl         String?
  iconUrl         String? // App icon for PWA/mobile (192x192)
  faviconUrl      String?
  primaryColor    String  @default("#3B82F6")
  secondaryColor  String  @default("#10B981")
  accentColor     String  @default("#d3f931") // Third brand color for highlights
  backgroundColor String  @default("#F9FAFB") // Page background color
  buttonTextColor String  @default("auto") // 'auto', 'light', 'dark' - controls text color on buttons
  customCss       String? // Custom CSS overrides

  // Database Configuration (for future isolation)
  databaseUrl String? // Optional: for dedicated databases
  schemaName  String? // Optional: for schema-per-clinic

  // Relations
  users               User[]
  providers           Provider[]
  patients            Patient[]
  inviteCodes         ClinicInviteCode[]
  orders              Order[]
  tickets             Ticket[]
  intakeTemplates     IntakeFormTemplate[]
  invoices            Invoice[]
  payments            Payment[]
  paymentMethods      PaymentMethod[]
  subscriptions       Subscription[]
  soapNotes           SOAPNote[]
  documents           PatientDocument[]
  auditLogs           ClinicAuditLog[]
  aiConversations     AIConversation[]
  influencers         Influencer[]
  referralTrackings   ReferralTracking[]
  commissions         Commission[]
  internalMessages    InternalMessage[]
  webhookLogs         WebhookLog[]
  integrationConfigs  Integration[]
  apiKeys             ApiKey[]
  webhookConfigs      WebhookConfig[]
  systemSettings      SystemSettings[]
  userClinics         UserClinic[] // Multi-clinic user assignments
  providerClinics     ProviderClinic[] // ENTERPRISE: Multi-clinic provider assignments
  salesRepAssignments PatientSalesRepAssignment[] // Sales rep patient assignments
  reconciliations     PaymentReconciliation[]
  patientCounter      PatientCounter? // Clinic-specific patient numbering

  // Scheduling & Care Plan Relations
  appointments         Appointment[]
  appointmentTypes     AppointmentTypeConfig[]
  providerAvailability ProviderAvailability[]
  providerTimeOff      ProviderTimeOff[]
  superbills           Superbill[]
  billingCodes         BillingCode[]
  carePlans            CarePlan[]
  carePlanTemplates    CarePlanTemplate[]
  smsLogs              SmsLog[]
  patientChatMessages  PatientChatMessage[]

  // Health Tracking Logs
  waterLogs     PatientWaterLog[]
  exerciseLogs  PatientExerciseLog[]
  sleepLogs     PatientSleepLog[]
  nutritionLogs PatientNutritionLog[]

  // Product Catalog
  products Product[]

  // Pricing & Promotions
  discountCodes        DiscountCode[]
  promotions           Promotion[]
  productBundles       ProductBundle[]
  pricingRules         PricingRule[]
  affiliateProgram     AffiliateProgram?
  affiliateReferrals   AffiliateReferral[]
  affiliateCommissions AffiliateCommission[]
  retentionOffers      RetentionOffer[]

  // New Affiliate Portal System
  affiliates                Affiliate[]
  affiliateApplications     AffiliateApplication[]
  affiliateRefCodes         AffiliateRefCode[]
  affiliateCommissionPlans  AffiliateCommissionPlan[]
  affiliatePlanAssignments  AffiliatePlanAssignment[]
  affiliateCommissionEvents AffiliateCommissionEvent[]

  // Enterprise Affiliate System
  affiliateTouches           AffiliateTouch[]
  affiliateAttributionConfig AffiliateAttributionConfig?
  affiliatePayouts           AffiliatePayout[]
  affiliateFraudAlerts       AffiliateFraudAlert[]
  affiliateFraudConfig       AffiliateFraudConfig?
  affiliateCompetitions      AffiliateCompetition[]

  // Lifefile Shipping Updates
  shippingUpdates PatientShippingUpdate[]

  // Gamification
  challenges Challenge[]

  // Prescription Refill Queue
  refillQueue RefillQueue[]

  // Financial Analytics
  financialMetrics FinancialMetrics[]
  savedReports     SavedReport[]
  reportExports    ReportExport[]

  // Provider Routing & Compensation (Enterprise feature)
  providerRoutingConfig      ProviderRoutingConfig?
  providerCompensationPlans  ProviderCompensationPlan[]
  providerCompensationEvents ProviderCompensationEvent[]

  // SOC 2 Policy Management
  policyAcknowledgments PolicyAcknowledgment[]

  // Telehealth & Calendar
  telehealthSessions    TelehealthSession[]
  calendarSubscriptions CalendarSubscription[]

  // In-App Notifications
  notifications Notification[]

  @@index([subdomain])
  @@index([status])
  @@index([customDomain])
}

model ClinicAuditLog {
  id        Int      @id @default(autoincrement())
  createdAt DateTime @default(now())
  clinicId  Int
  clinic    Clinic   @relation(fields: [clinicId], references: [id])
  action    String // CREATE, UPDATE, DELETE, STATUS_CHANGE, BILLING_CHANGE, etc.
  userId    Int?
  user      User?    @relation(fields: [userId], references: [id])
  details   Json? // Detailed change information
  ipAddress String?
  userAgent String?

  @@index([clinicId, createdAt])
  @@index([action])
}

enum ClinicStatus {
  ACTIVE
  INACTIVE
  SUSPENDED
  TRIAL
  EXPIRED
  PENDING_SETUP
}

// ===== SCHEDULING SYSTEM =====

enum AppointmentStatus {
  SCHEDULED
  CONFIRMED
  CHECKED_IN
  IN_PROGRESS
  COMPLETED
  CANCELLED
  NO_SHOW
  RESCHEDULED
}

enum AppointmentModeType {
  IN_PERSON
  VIDEO
  PHONE
}

enum ReminderType {
  EMAIL
  SMS
  BOTH
}

enum ReminderStatus {
  PENDING
  SENT
  FAILED
  CANCELLED
}

model AppointmentTypeConfig {
  id                   Int                 @id @default(autoincrement())
  clinicId             Int?
  clinic               Clinic?             @relation(fields: [clinicId], references: [id])
  name                 String
  description          String?
  duration             Int                 @default(30) // in minutes
  color                String              @default("#3B82F6")
  isActive             Boolean             @default(true)
  requiresVideoLink    Boolean             @default(false)
  allowSelfScheduling  Boolean             @default(true)
  bufferBefore         Int                 @default(0) // minutes before
  bufferAfter          Int                 @default(0) // minutes after
  price                Int? // in cents
  intakeFormTemplateId Int?
  intakeFormTemplate   IntakeFormTemplate? @relation(fields: [intakeFormTemplateId], references: [id])
  appointments         Appointment[]
  createdAt            DateTime            @default(now())
  updatedAt            DateTime            @updatedAt

  @@index([clinicId])
}

model ProviderAvailability {
  id               Int      @id @default(autoincrement())
  providerId       Int
  provider         Provider @relation(fields: [providerId], references: [id])
  clinicId         Int?
  clinic           Clinic?  @relation(fields: [clinicId], references: [id])
  dayOfWeek        Int // 0 = Sunday, 6 = Saturday
  startTime        String // "09:00"
  endTime          String // "17:00"
  isActive         Boolean  @default(true)
  locationId       Int?
  appointmentTypes Json? // Array of allowed appointment type IDs
  createdAt        DateTime @default(now())
  updatedAt        DateTime @updatedAt

  @@index([providerId])
  @@index([dayOfWeek])
}

model ProviderTimeOff {
  id          Int       @id @default(autoincrement())
  providerId  Int
  provider    Provider  @relation(fields: [providerId], references: [id])
  clinicId    Int?
  clinic      Clinic?   @relation(fields: [clinicId], references: [id])
  startDate   DateTime
  endDate     DateTime
  startTime   DateTime?
  endTime     DateTime?
  reason      String?
  isApproved  Boolean   @default(true)
  isAllDay    Boolean   @default(false)
  isRecurring Boolean   @default(false)
  source      String? // 'manual', 'calendar_sync'
  createdAt   DateTime  @default(now())

  @@index([providerId])
  @@index([startDate, endDate])
}

model ProviderCalendarIntegration {
  id            Int       @id @default(autoincrement())
  providerId    Int
  provider      String // 'google', 'outlook'
  clinicId      Int?
  accessToken   String?
  refreshToken  String?
  expiresAt     DateTime?
  accountId     String?
  calendarId    String?   @default("primary")
  isActive      Boolean   @default(true)
  syncEnabled   Boolean   @default(true)
  syncDirection String    @default("both") // 'to_external', 'from_external', 'both'
  lastSyncAt    DateTime?
  lastError     String?
  createdAt     DateTime  @default(now())
  updatedAt     DateTime  @updatedAt

  @@unique([providerId, provider], name: "providerId_provider")
  @@index([providerId])
}

model Appointment {
  id                     Int                    @id @default(autoincrement())
  clinicId               Int?
  clinic                 Clinic?                @relation(fields: [clinicId], references: [id])
  patientId              Int
  patient                Patient                @relation(fields: [patientId], references: [id])
  providerId             Int
  provider               Provider               @relation(fields: [providerId], references: [id])
  appointmentTypeId      Int?
  appointmentType        AppointmentTypeConfig? @relation(fields: [appointmentTypeId], references: [id])
  title                  String?
  startTime              DateTime
  endTime                DateTime
  duration               Int                    @default(30)
  type                   AppointmentModeType    @default(IN_PERSON)
  status                 AppointmentStatus      @default(SCHEDULED)
  reason                 String?
  notes                  String? // Patient-visible notes
  internalNotes          String? // Provider-only notes
  location               String?
  roomNumber             String?
  videoLink              String?
  zoomMeetingId          String?
  confirmedAt            DateTime?
  checkedInAt            DateTime?
  startedAt              DateTime?
  completedAt            DateTime?
  cancelledAt            DateTime?
  cancellationReason     String?
  rescheduledFromId      Int?
  rescheduledToId        Int?
  noShowAt               DateTime?
  createdById            Int?
  createdBy              User?                  @relation("AppointmentCreatedBy", fields: [createdById], references: [id])
  createdAt              DateTime               @default(now())
  updatedAt              DateTime               @updatedAt
  metadata               Json?
  reminders              AppointmentReminder[]
  superbills             Superbill[]
  telehealthSessions     TelehealthSession[]
  googleCalendarEventId  String?
  outlookCalendarEventId String?
  appleCalendarEventId   String?
  zoomJoinUrl            String?

  @@index([clinicId])
  @@index([patientId])
  @@index([providerId])
  @@index([startTime])
  @@index([status])
}

model AppointmentReminder {
  id            Int            @id @default(autoincrement())
  appointmentId Int
  appointment   Appointment    @relation(fields: [appointmentId], references: [id], onDelete: Cascade)
  type          ReminderType   @default(BOTH)
  scheduledFor  DateTime
  status        ReminderStatus @default(PENDING)
  sentAt        DateTime?
  errorMessage  String?
  messageId     String? // Twilio message ID or email ID
  template      String? // Which template was used
  createdAt     DateTime       @default(now())

  @@index([appointmentId])
  @@index([scheduledFor, status])
}

// ===== SUPERBILL / INSURANCE SYSTEM =====

model Superbill {
  id             Int             @id @default(autoincrement())
  clinicId       Int?
  clinic         Clinic?         @relation(fields: [clinicId], references: [id])
  patientId      Int
  patient        Patient         @relation(fields: [patientId], references: [id])
  providerId     Int
  provider       Provider        @relation(fields: [providerId], references: [id])
  appointmentId  Int?
  appointment    Appointment?    @relation(fields: [appointmentId], references: [id])
  serviceDate    DateTime
  totalAmount    Int             @default(0) // in cents
  paidAmount     Int             @default(0) // in cents
  status         String          @default("DRAFT") // DRAFT, FINALIZED, SENT, PAID
  pdfUrl         String?
  pdfGeneratedAt DateTime?
  sentToPatient  Boolean         @default(false)
  sentAt         DateTime?
  notes          String?
  items          SuperbillItem[]
  createdAt      DateTime        @default(now())
  updatedAt      DateTime        @updatedAt

  @@index([clinicId])
  @@index([patientId])
  @@index([providerId])
  @@index([serviceDate])
}

model SuperbillItem {
  id              Int       @id @default(autoincrement())
  superbillId     Int
  superbill       Superbill @relation(fields: [superbillId], references: [id], onDelete: Cascade)
  cptCode         String
  cptDescription  String
  icdCodes        String[] // Array of ICD-10 codes
  icdDescriptions String[] // Array of ICD-10 descriptions
  modifier        String? // CPT modifier (e.g., "25")
  units           Int       @default(1)
  unitPrice       Int // in cents
  totalPrice      Int // in cents
  notes           String?
  createdAt       DateTime  @default(now())

  @@index([superbillId])
}

model BillingCode {
  id           Int      @id @default(autoincrement())
  clinicId     Int?
  clinic       Clinic?  @relation(fields: [clinicId], references: [id])
  codeType     String // "CPT" or "ICD10"
  code         String
  description  String
  defaultPrice Int? // in cents (for CPT)
  category     String? // e.g., "Evaluation", "Procedure", "Lab"
  isActive     Boolean  @default(true)
  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt

  @@unique([clinicId, codeType, code])
}

// ===== CARE PLAN SYSTEM =====

enum CarePlanStatus {
  DRAFT
  ACTIVE
  COMPLETED
  ARCHIVED
  CANCELLED
}

enum GoalStatus {
  NOT_STARTED
  IN_PROGRESS
  COMPLETED
  PAUSED
  CANCELLED
}

model CarePlan {
  id                Int                @id @default(autoincrement())
  clinicId          Int?
  clinic            Clinic?            @relation(fields: [clinicId], references: [id])
  patientId         Int
  patient           Patient            @relation(fields: [patientId], references: [id])
  providerId        Int?
  provider          Provider?          @relation(fields: [providerId], references: [id])
  title             String
  description       String?
  status            CarePlanStatus     @default(DRAFT)
  startDate         DateTime?
  endDate           DateTime?
  templateId        Int?
  template          CarePlanTemplate?  @relation(fields: [templateId], references: [id])
  pdfUrl            String?
  patientSignature  String? // Base64 signature
  patientSignedAt   DateTime?
  providerSignature String?
  providerSignedAt  DateTime?
  activatedAt       DateTime?
  completedAt       DateTime?
  notes             String?
  metadata          Json?
  goals             CarePlanGoal[]
  activities        CarePlanActivity[]
  progress          CarePlanProgress[]
  createdAt         DateTime           @default(now())
  updatedAt         DateTime           @updatedAt

  @@index([clinicId])
  @@index([patientId])
  @@index([status])
}

model CarePlanTemplate {
  id                  Int        @id @default(autoincrement())
  clinicId            Int?
  clinic              Clinic?    @relation(fields: [clinicId], references: [id])
  name                String
  description         String?
  treatmentType       String? // e.g., "weight-loss", "hormone-therapy"
  defaultDurationDays Int?       @default(90)
  isActive            Boolean    @default(true)
  content             Json // Template structure with goals, activities
  createdById         Int?
  createdBy           User?      @relation(fields: [createdById], references: [id])
  carePlans           CarePlan[]
  createdAt           DateTime   @default(now())
  updatedAt           DateTime   @updatedAt

  @@index([clinicId])
}

model CarePlanGoal {
  id           Int                @id @default(autoincrement())
  carePlanId   Int
  carePlan     CarePlan           @relation(fields: [carePlanId], references: [id], onDelete: Cascade)
  title        String
  description  String?
  targetValue  String? // e.g., "180" for target weight
  currentValue String? // e.g., "200" for current weight
  unit         String? // e.g., "lbs", "mg/dL"
  status       GoalStatus         @default(NOT_STARTED)
  targetDate   DateTime?
  completedAt  DateTime?
  orderIndex   Int                @default(0)
  activities   CarePlanActivity[]
  progress     CarePlanProgress[]
  createdAt    DateTime           @default(now())
  updatedAt    DateTime           @updatedAt

  @@index([carePlanId])
}

model CarePlanActivity {
  id           Int                @id @default(autoincrement())
  carePlanId   Int
  carePlan     CarePlan           @relation(fields: [carePlanId], references: [id], onDelete: Cascade)
  goalId       Int?
  goal         CarePlanGoal?      @relation(fields: [goalId], references: [id])
  title        String
  description  String?
  frequency    String? // e.g., "daily", "weekly", "3x per week"
  instructions String?
  orderIndex   Int                @default(0)
  progress     CarePlanProgress[]
  createdAt    DateTime           @default(now())

  @@index([carePlanId])
}

model CarePlanProgress {
  id                Int               @id @default(autoincrement())
  carePlanId        Int
  carePlan          CarePlan          @relation(fields: [carePlanId], references: [id], onDelete: Cascade)
  goalId            Int?
  goal              CarePlanGoal?     @relation(fields: [goalId], references: [id])
  activityId        Int?
  activity          CarePlanActivity? @relation(fields: [activityId], references: [id])
  value             String? // Recorded value
  notes             String?
  recordedById      Int?
  recordedBy        User?             @relation(fields: [recordedById], references: [id])
  recordedByPatient Boolean           @default(false)
  recordedAt        DateTime          @default(now())

  @@index([carePlanId])
  @@index([recordedAt])
}

// ===== SMS MESSAGE LOG =====

model SmsLog {
  id         Int      @id @default(autoincrement())
  createdAt  DateTime @default(now())
  clinicId   Int?
  clinic     Clinic?  @relation(fields: [clinicId], references: [id])
  patientId  Int?
  patient    Patient? @relation(fields: [patientId], references: [id])
  messageSid String?  @unique // Twilio message SID
  fromPhone  String // Sender phone number
  toPhone    String // Recipient phone number
  body       String // Message content
  direction  String // 'inbound' or 'outbound'
  status     String   @default("sent") // sent, delivered, failed, etc.
  error      String? // Error message if failed
  metadata   Json? // Additional data

  @@index([patientId, createdAt])
  @@index([fromPhone])
  @@index([toPhone])
  @@index([clinicId])
}

// ===== PATIENT CHAT SYSTEM =====

model PatientChatMessage {
  id        Int      @id @default(autoincrement())
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  clinicId  Int?
  clinic    Clinic?  @relation(fields: [clinicId], references: [id])
  patientId Int
  patient   Patient  @relation(fields: [patientId], references: [id])

  // Message content
  message   String // The message text
  direction MessageDirection // INBOUND (patient->staff) or OUTBOUND (staff->patient)
  channel   MessageChannel   @default(WEB) // WEB, SMS, EMAIL

  // Sender info
  senderType SenderType // PATIENT, STAFF, PROVIDER, SYSTEM
  senderId   Int? // User ID if staff/provider, null if patient
  senderName String? // Display name of sender

  // Delivery status (for SMS/email)
  status        MessageStatus @default(SENT)
  externalId    String? // Twilio message SID or external reference
  deliveredAt   DateTime?
  readAt        DateTime?
  failureReason String?

  // Thread support
  threadId  String? // Group messages into threads
  replyToId Int? // Reply to specific message
  replyTo   PatientChatMessage?  @relation("MessageReplies", fields: [replyToId], references: [id])
  replies   PatientChatMessage[] @relation("MessageReplies")

  // Attachments
  attachments Json? // Array of attachment URLs

  // Metadata
  metadata Json? // Additional data (device info, etc.)

  @@index([patientId, createdAt])
  @@index([clinicId])
  @@index([threadId])
  @@index([status])
}

enum MessageDirection {
  INBOUND // Patient -> Staff
  OUTBOUND // Staff -> Patient
}

enum MessageChannel {
  WEB // In-app web chat
  SMS // Twilio SMS
  EMAIL // Email
}

enum SenderType {
  PATIENT
  STAFF
  PROVIDER
  SYSTEM
}

enum MessageStatus {
  PENDING // Queued for delivery
  SENT // Sent but not confirmed delivered
  DELIVERED // Confirmed delivered
  READ // Read by recipient
  FAILED // Delivery failed
}

// ===== PUSH NOTIFICATIONS =====

model PushSubscription {
  id        Int      @id @default(autoincrement())
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  patientId Int
  patient   Patient @relation(fields: [patientId], references: [id], onDelete: Cascade)

  // Web Push subscription data
  endpoint String @unique
  p256dh   String // Public key
  auth     String // Auth secret

  // Metadata
  userAgent  String?
  deviceType String? // mobile, desktop, tablet

  @@index([patientId])
}

// ===== GAMIFICATION SYSTEM =====

model PatientStreak {
  id        Int      @id @default(autoincrement())
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  patientId Int
  patient   Patient @relation(fields: [patientId], references: [id], onDelete: Cascade)

  // Streak tracking
  streakType      StreakType // DAILY_CHECK_IN, WEIGHT_LOG, WATER_LOG, EXERCISE, etc.
  currentStreak   Int        @default(0)
  longestStreak   Int        @default(0)
  lastActivityAt  DateTime?
  streakStartedAt DateTime?

  // Streak freeze (one per month)
  freezesUsed    Int       @default(0)
  freezesAllowed Int       @default(1) // Resets monthly
  lastFreezeAt   DateTime?

  @@unique([patientId, streakType])
  @@index([patientId])
}

enum StreakType {
  DAILY_CHECK_IN
  WEIGHT_LOG
  WATER_LOG
  EXERCISE_LOG
  MEAL_LOG
  MEDICATION_TAKEN
  SLEEP_LOG
}

model Achievement {
  id        Int      @id @default(autoincrement())
  createdAt DateTime @default(now())

  // Achievement definition
  code        String              @unique // e.g., "first_weigh_in", "streak_7_day"
  name        String
  description String
  category    AchievementCategory
  icon        String? // Icon name or URL
  points      Int                 @default(10)

  // Unlock criteria
  criteria Json // { type: "streak", streakType: "WEIGHT_LOG", value: 7 }
  isSecret Boolean @default(false) // Hidden until unlocked

  // Display
  tier      AchievementTier @default(BRONZE)
  sortOrder Int             @default(0)

  // Relations
  unlockedBy PatientAchievement[]
}

enum AchievementCategory {
  GETTING_STARTED
  CONSISTENCY
  WEIGHT_LOSS
  HEALTH_TRACKING
  ENGAGEMENT
  MILESTONES
  SPECIAL
}

enum AchievementTier {
  BRONZE
  SILVER
  GOLD
  PLATINUM
  DIAMOND
}

model PatientAchievement {
  id        Int      @id @default(autoincrement())
  createdAt DateTime @default(now())

  patientId     Int
  patient       Patient     @relation(fields: [patientId], references: [id], onDelete: Cascade)
  achievementId Int
  achievement   Achievement @relation(fields: [achievementId], references: [id])

  // When earned
  unlockedAt DateTime @default(now())
  seen       Boolean  @default(false) // Has patient seen the notification?

  // Progress toward achievement (for partial progress display)
  progress Int @default(100) // 0-100

  @@unique([patientId, achievementId])
  @@index([patientId])
}

model PatientPoints {
  id        Int      @id @default(autoincrement())
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  patientId Int     @unique
  patient   Patient @relation(fields: [patientId], references: [id], onDelete: Cascade)

  totalPoints  Int    @default(0)
  currentLevel Int    @default(1)
  levelName    String @default("Beginner")

  // Points breakdown
  achievementPoints Int @default(0)
  streakPoints      Int @default(0)
  activityPoints    Int @default(0)
}

model PointsHistory {
  id        Int      @id @default(autoincrement())
  createdAt DateTime @default(now())

  patientId Int
  patient   Patient @relation(fields: [patientId], references: [id], onDelete: Cascade)

  points      Int
  reason      String // "achievement_unlocked", "streak_bonus", "daily_log"
  description String?
  referenceId String? // Achievement ID, etc.

  @@index([patientId])
  @@index([createdAt])
}

model Challenge {
  id        Int      @id @default(autoincrement())
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  clinicId Int?
  clinic   Clinic? @relation(fields: [clinicId], references: [id])

  // Challenge details
  name        String
  description String
  type        ChallengeType
  imageUrl    String?

  // Duration
  startDate DateTime
  endDate   DateTime

  // Goals
  targetValue Int // e.g., 30 days, 100 oz water
  targetUnit  String // "days", "oz", "minutes", etc.

  // Rewards
  points Int     @default(100)
  badge  String? // Achievement code to unlock

  // Status
  isActive Boolean @default(true)
  isPublic Boolean @default(true) // Visible to all patients

  participants ChallengeParticipant[]
}

enum ChallengeType {
  STREAK // Complete X consecutive days
  CUMULATIVE // Accumulate X total
  MILESTONE // Reach specific goal
  COMPETITION // Compare with others
}

model ChallengeParticipant {
  id        Int      @id @default(autoincrement())
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  challengeId Int
  challenge   Challenge @relation(fields: [challengeId], references: [id], onDelete: Cascade)
  patientId   Int
  patient     Patient   @relation(fields: [patientId], references: [id], onDelete: Cascade)

  // Progress
  currentValue Int       @default(0)
  completedAt  DateTime?
  rank         Int?

  @@unique([challengeId, patientId])
  @@index([patientId])
}

// ===== PRODUCT CATALOG =====

model Product {
  id        Int      @id @default(autoincrement())
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  clinicId  Int
  clinic    Clinic   @relation(fields: [clinicId], references: [id])

  // Basic Information
  name             String // e.g., "Semaglutide 0-1.25mg Monthly"
  description      String? // Detailed description
  shortDescription String? // For invoices/receipts
  category         ProductCategory @default(SERVICE)

  // Pricing
  price    Int // Price in cents
  currency String @default("usd")

  // Billing Type
  billingType          BillingType      @default(ONE_TIME)
  billingInterval      BillingInterval? // For recurring: MONTHLY, QUARTERLY, etc.
  billingIntervalCount Int              @default(1) // e.g., 3 for quarterly (3 months)

  // Trial Period (for subscriptions)
  trialDays Int? // Optional trial period

  // Stripe Integration
  stripeProductId String? @unique // Stripe Product ID
  stripePriceId   String? @unique // Stripe Price ID

  // Status & Visibility
  isActive     Boolean @default(true)
  isVisible    Boolean @default(true) // Show in patient-facing catalog
  displayOrder Int     @default(0) // For sorting

  // Inventory (optional)
  trackInventory    Boolean @default(false)
  inventoryCount    Int?
  lowStockThreshold Int?

  // Tax
  taxable Boolean @default(false)
  taxRate Float? // e.g., 0.07 for 7%

  // Metadata
  metadata Json? // Additional custom data
  tags     Json? // Array of tags for filtering

  // Relations
  invoiceItems InvoiceItem[]
  bundleItems  ProductBundleItem[]

  @@index([clinicId, isActive])
  @@index([clinicId, category])
  @@index([stripeProductId])
}

model InvoiceItem {
  id          Int      @id @default(autoincrement())
  createdAt   DateTime @default(now())
  invoiceId   Int
  invoice     Invoice  @relation(fields: [invoiceId], references: [id], onDelete: Cascade)
  productId   Int?
  product     Product? @relation(fields: [productId], references: [id])
  description String // Line item description
  quantity    Int      @default(1)
  unitPrice   Int // Price per unit in cents
  amount      Int // Total amount (quantity * unitPrice)
  metadata    Json?

  @@index([invoiceId])
  @@index([productId])
}

enum ProductCategory {
  SERVICE // Medical services, consultations
  MEDICATION // Prescription medications
  SUPPLEMENT // OTC supplements
  LAB_TEST // Lab work, tests
  PROCEDURE // Medical procedures
  PACKAGE // Bundled services
  MEMBERSHIP // Membership/subscription plans
  OTHER
}

enum BillingType {
  ONE_TIME // Single payment
  RECURRING // Subscription
}

enum BillingInterval {
  WEEKLY
  MONTHLY
  QUARTERLY // Every 3 months
  SEMI_ANNUAL // Every 6 months
  ANNUAL // Yearly
  CUSTOM // Custom interval using billingIntervalCount
}

// ===== DISCOUNT & PROMO CODE SYSTEM =====

model DiscountCode {
  id        Int      @id @default(autoincrement())
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  clinicId  Int
  clinic    Clinic   @relation(fields: [clinicId], references: [id])

  // Code Details
  code        String // e.g., "WELCOME20", "SUMMER2026"
  name        String // Display name: "Welcome Discount"
  description String? // Internal description

  // Discount Type
  discountType  DiscountType @default(PERCENTAGE)
  discountValue Float // 20 for 20% or 2000 for $20 off (cents)

  // Applicability
  applyTo           DiscountApplyTo @default(ALL_PRODUCTS)
  productIds        Json? // Specific product IDs if LIMITED_PRODUCTS
  categoryIds       Json? // Specific categories if LIMITED_CATEGORIES
  excludeProductIds Json? // Products to exclude

  // Usage Limits
  maxUses           Int? // Total uses allowed (null = unlimited)
  maxUsesPerPatient Int? // Per patient limit (null = unlimited)
  currentUses       Int  @default(0)

  // Validity
  startsAt  DateTime  @default(now())
  expiresAt DateTime? // null = never expires
  isActive  Boolean   @default(true)

  // Requirements
  minOrderAmount Int? // Minimum order in cents
  minQuantity    Int? // Minimum quantity of items
  firstTimeOnly  Boolean @default(false) // Only for new patients

  // Subscription Specifics
  applyToFirstPayment Boolean @default(true)
  applyToRecurring    Boolean @default(false)
  recurringDuration   Int? // How many billing cycles to apply (null = all)

  // Stripe Integration
  stripeCouponId String? @unique

  // Tracking
  affiliateId Int? // If code belongs to affiliate
  affiliate   Influencer? @relation(fields: [affiliateId], references: [id])

  // Usage Records
  usages DiscountUsage[]

  @@unique([clinicId, code])
  @@index([clinicId, isActive])
  @@index([code])
  @@index([affiliateId])
}

model DiscountUsage {
  id             Int          @id @default(autoincrement())
  createdAt      DateTime     @default(now())
  discountCodeId Int
  discountCode   DiscountCode @relation(fields: [discountCodeId], references: [id])
  patientId      Int
  patient        Patient      @relation(fields: [patientId], references: [id])
  invoiceId      Int?
  orderId        Int?
  amountSaved    Int // Amount saved in cents
  orderTotal     Int // Original order total

  @@index([discountCodeId])
  @@index([patientId])
}

enum DiscountType {
  PERCENTAGE // % off
  FIXED_AMOUNT // $ off
  FREE_SHIPPING // Free shipping
  FREE_TRIAL // Extended trial period
  BUY_X_GET_Y // Buy X get Y free/discounted
}

enum DiscountApplyTo {
  ALL_PRODUCTS
  LIMITED_PRODUCTS // Specific products only
  LIMITED_CATEGORIES // Specific categories only
  SUBSCRIPTIONS_ONLY // Only recurring products
  ONE_TIME_ONLY // Only one-time products
}

// ===== PROMOTIONS & SPECIALS =====

model Promotion {
  id        Int      @id @default(autoincrement())
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  clinicId  Int
  clinic    Clinic   @relation(fields: [clinicId], references: [id])

  // Basic Info
  name          String // "Summer Sale 2026"
  description   String?
  internalNotes String?

  // Promotion Type
  promotionType PromotionType @default(SALE)

  // Discount Configuration
  discountType  DiscountType @default(PERCENTAGE)
  discountValue Float

  // Applicability
  applyTo     DiscountApplyTo @default(ALL_PRODUCTS)
  productIds  Json?
  categoryIds Json?

  // Schedule
  startsAt DateTime
  endsAt   DateTime?
  isActive Boolean   @default(true)

  // Display
  bannerText     String? // "Save 20% - Limited Time!"
  bannerColor    String? // Hex color for banner
  showOnProducts Boolean @default(true)
  showBanner     Boolean @default(false)

  // Limits
  maxRedemptions     Int?
  currentRedemptions Int  @default(0)

  // Auto-apply
  autoApply      Boolean @default(true) // Automatically apply vs. need code
  requiresCode   Boolean @default(false)
  discountCodeId Int? // If requires code

  // Stripe
  stripeCouponId String?

  @@index([clinicId, isActive])
  @@index([startsAt, endsAt])
}

enum PromotionType {
  SALE // General sale
  FLASH_SALE // Limited time (hours)
  SEASONAL // Holiday/seasonal
  CLEARANCE // Clearance pricing
  NEW_PATIENT // New patient special
  LOYALTY // Loyalty reward
  BUNDLE // Bundle deal
  UPGRADE // Upgrade offer
}

// ===== PRODUCT BUNDLES =====

model ProductBundle {
  id        Int      @id @default(autoincrement())
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  clinicId  Int
  clinic    Clinic   @relation(fields: [clinicId], references: [id])

  // Bundle Info
  name             String // "3-Month Weight Loss Program"
  description      String?
  shortDescription String?

  // Pricing
  regularPrice   Int // Sum of individual products (cents)
  bundlePrice    Int // Discounted bundle price
  savingsAmount  Int // How much they save
  savingsPercent Float // Percentage saved

  // Products in Bundle
  items ProductBundleItem[]

  // Billing
  billingType     BillingType      @default(ONE_TIME)
  billingInterval BillingInterval?

  // Status
  isActive     Boolean @default(true)
  isVisible    Boolean @default(true)
  displayOrder Int     @default(0)

  // Stripe
  stripeProductId String? @unique
  stripePriceId   String? @unique

  // Limits
  maxPurchases     Int? // Max times can be purchased
  currentPurchases Int       @default(0)
  availableFrom    DateTime?
  availableUntil   DateTime?

  @@index([clinicId, isActive])
}

model ProductBundleItem {
  id        Int           @id @default(autoincrement())
  bundleId  Int
  bundle    ProductBundle @relation(fields: [bundleId], references: [id], onDelete: Cascade)
  productId Int
  product   Product       @relation(fields: [productId], references: [id])
  quantity  Int           @default(1)

  @@index([bundleId])
  @@index([productId])
}

// ===== PRICING RULES ENGINE =====

model PricingRule {
  id        Int      @id @default(autoincrement())
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  clinicId  Int
  clinic    Clinic   @relation(fields: [clinicId], references: [id])

  // Rule Info
  name        String // "Volume Discount Tier 1"
  description String?
  priority    Int     @default(0) // Higher = applied first

  // Rule Type
  ruleType PricingRuleType @default(VOLUME_DISCOUNT)

  // Conditions (JSON for flexibility)
  conditions Json // Array of condition objects
  // Example: [{"type": "quantity", "operator": ">=", "value": 5}]
  // Example: [{"type": "patientTag", "operator": "contains", "value": "VIP"}]

  // Action
  discountType  DiscountType @default(PERCENTAGE)
  discountValue Float

  // Applicability
  applyTo    DiscountApplyTo @default(ALL_PRODUCTS)
  productIds Json?

  // Status
  isActive Boolean   @default(true)
  startsAt DateTime?
  endsAt   DateTime?

  @@index([clinicId, isActive, priority])
}

enum PricingRuleType {
  VOLUME_DISCOUNT // Buy more, save more
  TIERED_PRICING // Price decreases at quantity thresholds
  PATIENT_SEGMENT // Based on patient attributes/tags
  LOYALTY_DISCOUNT // Based on purchase history
  TIME_BASED // Different prices at different times
  LOCATION_BASED // Based on patient location
  CUSTOM // Custom rule logic
}

// ===== AFFILIATE/REFERRAL PROGRAM ENHANCEMENTS =====

model AffiliateProgram {
  id        Int      @id @default(autoincrement())
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  clinicId  Int      @unique
  clinic    Clinic   @relation(fields: [clinicId], references: [id])

  // Program Settings
  name     String  @default("Affiliate Program")
  isActive Boolean @default(true)

  // Default Commission
  defaultCommissionType  CommissionType @default(PERCENTAGE)
  defaultCommissionValue Float          @default(10) // 10% or $10

  // Commission Rules
  commissionOnFirstPurchase   Boolean @default(true)
  commissionOnRecurring       Boolean @default(true)
  recurringCommissionDuration Int? // Months to pay recurring (null = lifetime)

  // Cookie/Attribution
  attributionWindowDays Int @default(30) // Days to attribute sale

  // Tiers
  tiers AffiliateTier[]

  // Payouts
  minimumPayout   Int             @default(5000) // $50 minimum
  payoutFrequency PayoutFrequency @default(MONTHLY)

  @@index([clinicId])
}

model AffiliateTier {
  id        Int              @id @default(autoincrement())
  programId Int
  program   AffiliateProgram @relation(fields: [programId], references: [id], onDelete: Cascade)

  // Tier Info
  name  String // "Bronze", "Silver", "Gold", "Platinum"
  level Int    @default(1) // 1, 2, 3, 4...

  // Requirements
  minReferrals Int @default(0) // Min referrals to reach tier
  minRevenue   Int @default(0) // Min revenue generated (cents)

  // Benefits
  commissionType  CommissionType @default(PERCENTAGE)
  commissionValue Float // Commission rate for this tier
  bonusAmount     Int? // One-time bonus for reaching tier

  // Perks
  perks Json? // Array of perk descriptions

  @@unique([programId, level])
  @@index([programId])
}

model AffiliateReferral {
  id        Int      @id @default(autoincrement())
  createdAt DateTime @default(now())
  clinicId  Int
  clinic    Clinic   @relation(fields: [clinicId], references: [id])

  // Referral Details
  affiliateId       Int // The influencer/affiliate
  affiliate         Influencer @relation(fields: [affiliateId], references: [id])
  referredPatientId Int // The patient who was referred
  referredPatient   Patient    @relation(fields: [referredPatientId], references: [id])

  // Attribution
  discountCodeUsed String? // Code they used
  landingPage      String? // Where they landed
  utmSource        String?
  utmMedium        String?
  utmCampaign      String?

  // Status
  status      ReferralStatus @default(PENDING)
  convertedAt DateTime? // When they made first purchase

  // Lifetime Value
  totalRevenue    Int @default(0) // Total revenue from this referral
  totalCommission Int @default(0) // Total commission paid

  @@index([affiliateId])
  @@index([referredPatientId])
  @@index([clinicId])
}

model AffiliateCommission {
  id        Int      @id @default(autoincrement())
  createdAt DateTime @default(now())
  clinicId  Int
  clinic    Clinic   @relation(fields: [clinicId], references: [id])

  // Commission Details
  affiliateId Int
  affiliate   Influencer @relation(fields: [affiliateId], references: [id])
  referralId  Int?

  // Source
  invoiceId      Int?
  orderId        Int?
  subscriptionId Int?

  // Amounts
  orderAmount      Int // Order/payment amount
  commissionRate   Float // Rate applied
  commissionAmount Int // Commission earned

  // Status
  status   CommissionStatus @default(PENDING)
  paidAt   DateTime?
  payoutId String? // External payout reference

  // Type
  commissionType String @default("first_purchase") // first_purchase, recurring, bonus

  @@index([affiliateId])
  @@index([clinicId])
  @@index([status])
}

enum CommissionType {
  PERCENTAGE
  FIXED_AMOUNT
}

enum PayoutFrequency {
  WEEKLY
  BIWEEKLY
  MONTHLY
  QUARTERLY
}

enum ReferralStatus {
  PENDING // Signed up but no purchase
  CONVERTED // Made first purchase
  ACTIVE // Active customer
  CHURNED // Cancelled/inactive
}

// ===== SUBSCRIPTION MANAGEMENT =====

model SubscriptionAction {
  id             Int          @id @default(autoincrement())
  createdAt      DateTime     @default(now())
  subscriptionId Int
  subscription   Subscription @relation(fields: [subscriptionId], references: [id])

  // Action Details
  actionType SubscriptionActionType
  reason     String?

  // For Pauses
  pausedUntil DateTime?

  // For Plan Changes
  previousPlanId String?
  newPlanId      String?
  previousAmount Int?
  newAmount      Int?

  // For Cancellation
  cancellationReason String?
  retentionOfferMade Boolean @default(false)
  retentionOfferId   Int?

  // Who performed
  performedBy String? // user ID or "system" or "patient"

  @@index([subscriptionId])
}

model RetentionOffer {
  id        Int      @id @default(autoincrement())
  createdAt DateTime @default(now())
  clinicId  Int
  clinic    Clinic   @relation(fields: [clinicId], references: [id])

  // Offer Info
  name        String // "Stay with us - 50% off next month"
  description String?

  // Offer Type
  offerType RetentionOfferType @default(DISCOUNT)

  // Discount (if applicable)
  discountType     DiscountType?
  discountValue    Float?
  discountDuration Int? // How many billing cycles

  // Free Period (if applicable)
  freeMonths Int?

  // Pause Option
  pauseDuration Int? // Days to pause

  // Targeting
  triggerOn          String @default("cancellation") // cancellation, payment_failed, etc.
  minSubscriptionAge Int? // Min days subscribed to show offer

  // Status
  isActive Boolean @default(true)

  // Stats
  timesShown    Int @default(0)
  timesAccepted Int @default(0)

  @@index([clinicId, isActive])
}

enum SubscriptionActionType {
  CREATED
  ACTIVATED
  PAUSED
  RESUMED
  UPGRADED
  DOWNGRADED
  CANCELLED
  REACTIVATED
  PAYMENT_FAILED
  PAYMENT_SUCCEEDED
  RETENTION_OFFERED
  RETENTION_ACCEPTED
  RETENTION_DECLINED
}

enum RetentionOfferType {
  DISCOUNT // Percentage or fixed off
  FREE_PERIOD // Free month(s)
  PAUSE // Pause subscription
  DOWNGRADE // Offer cheaper plan
  BONUS // Free add-on product
}

// ===== AFFILIATE PORTAL SYSTEM =====
// HIPAA-COMPLIANT: Affiliates only see aggregated metrics, never patient-level data

model Affiliate {
  id          Int             @id @default(autoincrement())
  createdAt   DateTime        @default(now())
  updatedAt   DateTime        @updatedAt
  clinicId    Int // Multi-tenant: affiliate belongs to a clinic
  clinic      Clinic          @relation(fields: [clinicId], references: [id])
  userId      Int             @unique // Link to User for login credentials
  user        User            @relation(fields: [userId], references: [id])
  displayName String // Display name shown in portal
  status      AffiliateStatus @default(ACTIVE)
  metadata    Json? // Additional affiliate info

  // Tier tracking (cached for performance)
  currentTierId        Int? // Current tier level
  currentTier          AffiliateCommissionTier? @relation(fields: [currentTierId], references: [id])
  tierQualifiedAt      DateTime? // When they qualified for current tier
  lifetimeConversions  Int                      @default(0)
  lifetimeRevenueCents Int                      @default(0)

  // Login tracking
  lastLoginAt DateTime?

  // Leaderboard settings
  leaderboardOptIn Boolean @default(false) // Whether affiliate appears on public leaderboards
  leaderboardAlias String? // Custom display name for leaderboard (if opt-in)

  // Relations
  refCodes           AffiliateRefCode[]
  planAssignments    AffiliatePlanAssignment[]
  commissionEvents   AffiliateCommissionEvent[]
  attributedPatients Patient[]
  touches            AffiliateTouch[]
  payoutMethods      AffiliatePayoutMethod[]
  payouts            AffiliatePayout[]
  taxDocuments       AffiliateTaxDocument[]
  fraudAlerts        AffiliateFraudAlert[]
  otpCode            AffiliateOtpCode?
  application        AffiliateApplication? // Link to original application (if created via self-signup)
  competitionEntries AffiliateCompetitionEntry[]

  @@index([clinicId])
  @@index([status])
}

// OTP codes for phone-based login
model AffiliateOtpCode {
  id          Int       @id @default(autoincrement())
  affiliateId Int       @unique
  affiliate   Affiliate @relation(fields: [affiliateId], references: [id], onDelete: Cascade)
  code        String // 6-digit code
  expiresAt   DateTime
  attempts    Int       @default(0) // Failed verification attempts
  createdAt   DateTime  @default(now())
}

// Self-service affiliate applications (pending approval)
model AffiliateApplication {
  id        Int      @id @default(autoincrement())
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  clinicId  Int
  clinic    Clinic   @relation(fields: [clinicId], references: [id])

  // Required applicant information
  fullName String
  email    String
  phone    String

  // Address
  addressLine1 String
  addressLine2 String?
  city         String
  state        String
  zipCode      String
  country      String  @default("US")

  // Social media profiles (JSON array: [{platform: "instagram", url: "..."}])
  socialProfiles Json

  // Optional additional info
  website       String?
  audienceSize  String? // e.g., "1K-10K", "10K-50K", "50K-100K", "100K+"
  promotionPlan String? // How they plan to promote

  // Application status
  status      AffiliateApplicationStatus @default(PENDING)
  reviewedAt  DateTime?
  reviewedBy  Int? // Admin user who reviewed
  reviewNotes String? // Internal notes from reviewer

  // If approved, link to created affiliate
  affiliateId Int?       @unique
  affiliate   Affiliate? @relation(fields: [affiliateId], references: [id])

  @@index([clinicId, status])
  @@index([email])
  @@index([phone])
}

model AffiliateRefCode {
  id          Int       @id @default(autoincrement())
  createdAt   DateTime  @default(now())
  clinicId    Int // Multi-tenant scoping
  clinic      Clinic    @relation(fields: [clinicId], references: [id])
  affiliateId Int
  affiliate   Affiliate @relation(fields: [affiliateId], references: [id])
  refCode     String // e.g., "infl_xxx", "partner_abc"
  description String? // Optional description of the ref code source
  isActive    Boolean   @default(true)

  @@unique([clinicId, refCode]) // Ref codes unique per clinic
  @@index([clinicId])
  @@index([affiliateId])
  @@index([refCode])
}

model AffiliateCommissionPlan {
  id              Int                 @id @default(autoincrement())
  createdAt       DateTime            @default(now())
  updatedAt       DateTime            @updatedAt
  clinicId        Int // Multi-tenant scoping
  clinic          Clinic              @relation(fields: [clinicId], references: [id])
  name            String // e.g., "Standard 10%", "VIP Partner 15%"
  description     String?
  planType        CommissionPlanType  @default(PERCENT)
  flatAmountCents Int? // Default flat-rate commission (in cents), used as fallback
  percentBps      Int? // Default percentage commission (basis points: 1000 = 10%), used as fallback
  appliesTo       CommissionAppliesTo @default(FIRST_PAYMENT_ONLY)
  holdDays        Int                 @default(0) // Days to hold before commission is approved
  clawbackEnabled Boolean             @default(false) // If true, refund/chargeback reverses commission
  isActive        Boolean             @default(true)

  // Initial/First Payment Commission (overrides default if set)
  initialPercentBps      Int? // e.g., 1000 = 10% for first payment
  initialFlatAmountCents Int? // e.g., 5000 = $50 for first payment

  // Recurring Payment Commission (overrides default if set)
  recurringPercentBps      Int? // e.g., 500 = 5% for recurring payments
  recurringFlatAmountCents Int? // e.g., 2500 = $25 for recurring payments

  // Tier-based commission
  tierEnabled Boolean @default(false)

  // Recurring commission settings
  recurringEnabled  Boolean @default(false)
  recurringMonths   Int? // null = lifetime recurring
  recurringDecayPct Int? // e.g., 50 = 50% of original rate after year 1

  // Relations
  assignments  AffiliatePlanAssignment[]
  tiers        AffiliateCommissionTier[]
  productRules AffiliateProductRate[]
  promotions   AffiliatePromotion[]

  @@index([clinicId])
  @@index([isActive])
}

model AffiliatePlanAssignment {
  id               Int                     @id @default(autoincrement())
  createdAt        DateTime                @default(now())
  clinicId         Int // Multi-tenant scoping
  clinic           Clinic                  @relation(fields: [clinicId], references: [id])
  affiliateId      Int
  affiliate        Affiliate               @relation(fields: [affiliateId], references: [id])
  commissionPlanId Int
  commissionPlan   AffiliateCommissionPlan @relation(fields: [commissionPlanId], references: [id])
  effectiveFrom    DateTime                @default(now())
  effectiveTo      DateTime? // Null = no expiry

  @@index([clinicId])
  @@index([affiliateId])
  @@index([commissionPlanId])
  @@index([effectiveFrom, effectiveTo])
}

// Immutable ledger of commission events - NEVER store patient-level data here
model AffiliateCommissionEvent {
  id          Int       @id @default(autoincrement())
  createdAt   DateTime  @default(now())
  clinicId    Int // Multi-tenant scoping
  clinic      Clinic    @relation(fields: [clinicId], references: [id])
  affiliateId Int
  affiliate   Affiliate @relation(fields: [affiliateId], references: [id])

  // Stripe event tracking for idempotency
  stripeEventId   String // Stripe event ID (evt_xxx)
  stripeObjectId  String // Payment intent/charge/session ID
  stripeEventType String // e.g., "payment_intent.succeeded"

  // Commission details (HIPAA-SAFE: no patient identifiers)
  eventAmountCents      Int // Total payment amount
  commissionAmountCents Int // Calculated commission
  commissionPlanId      Int? // Plan used for calculation (null if plan deleted)

  // Commission breakdown (for tiered/promotional calculations)
  baseCommissionCents    Int? // Base commission before adjustments
  tierBonusCents         Int? // Tier-based bonus
  promotionBonusCents    Int? // Promotional bonus
  productAdjustmentCents Int? // Product-specific adjustment

  // Attribution tracking
  touchId          Int? // Link to the touch that attributed this conversion
  attributionModel String? // Which model was used (FIRST_CLICK, LAST_CLICK, etc.)

  // Recurring tracking
  isRecurring     Boolean @default(false)
  recurringMonth  Int? // Which month of recurring (1, 2, 3...)
  originalEventId Int? // Link to first commission event for this subscription

  // Status tracking
  status         CommissionEventStatus @default(PENDING)
  occurredAt     DateTime // When the payment occurred
  holdUntil      DateTime? // When commission becomes eligible for approval
  approvedAt     DateTime?
  paidAt         DateTime?
  reversedAt     DateTime?
  reversalReason String? // e.g., "refund", "chargeback"

  // Payout tracking
  payoutId Int? // Which payout included this commission
  payout   AffiliatePayout? @relation(fields: [payoutId], references: [id])

  // Audit trail
  metadata Json? // Additional non-PHI context

  @@unique([clinicId, stripeEventId]) // Idempotency: one event per stripe event per clinic
  @@index([clinicId])
  @@index([affiliateId])
  @@index([status])
  @@index([occurredAt])
  @@index([stripeEventId])
  @@index([payoutId])
}

enum AffiliateStatus {
  ACTIVE
  PAUSED
  SUSPENDED
  INACTIVE
}

enum AffiliateApplicationStatus {
  PENDING
  APPROVED
  REJECTED
}

enum CommissionPlanType {
  FLAT // Flat dollar amount per conversion
  PERCENT // Percentage of revenue
}

enum CommissionAppliesTo {
  FIRST_PAYMENT_ONLY // Commission only on first payment
  ALL_PAYMENTS // Commission on all payments (recurring)
}

enum CommissionEventStatus {
  PENDING // Waiting for hold period
  APPROVED // Hold period passed, ready for payout
  PAID // Commission paid out
  REVERSED // Clawed back due to refund/chargeback
}

// ===== AFFILIATE COMPETITIONS & LEADERBOARDS =====

// Competition/challenge for affiliates (managed by clinic admins)
model AffiliateCompetition {
  id               Int               @id @default(autoincrement())
  createdAt        DateTime          @default(now())
  updatedAt        DateTime          @updatedAt
  clinicId         Int
  clinic           Clinic            @relation(fields: [clinicId], references: [id])
  name             String // e.g., "January Sales Sprint"
  description      String? // Detailed description of the competition
  metric           CompetitionMetric // What metric is being tracked
  startDate        DateTime // When competition starts
  endDate          DateTime // When competition ends
  status           CompetitionStatus @default(SCHEDULED)
  prizeDescription String? // e.g., "$500 bonus", "Free trip to Vegas"
  prizeValueCents  Int? // Monetary value of prize in cents
  minParticipants  Int               @default(0) // Minimum participants required
  isPublic         Boolean           @default(true) // Show on affiliate leaderboard page

  // Relations
  entries AffiliateCompetitionEntry[]

  @@index([clinicId])
  @@index([status])
  @@index([startDate, endDate])
}

// Entry/participation in a competition
model AffiliateCompetitionEntry {
  id            Int                  @id @default(autoincrement())
  createdAt     DateTime             @default(now())
  updatedAt     DateTime             @updatedAt
  competitionId Int
  competition   AffiliateCompetition @relation(fields: [competitionId], references: [id], onDelete: Cascade)
  affiliateId   Int
  affiliate     Affiliate            @relation(fields: [affiliateId], references: [id], onDelete: Cascade)
  currentValue  Int                  @default(0) // Current score (clicks, conversions, or cents depending on metric)
  rank          Int? // Current rank in competition (updated by cron)

  @@unique([competitionId, affiliateId])
  @@index([competitionId, rank])
  @@index([affiliateId])
}

enum CompetitionMetric {
  CLICKS // Most clicks
  CONVERSIONS // Most conversions/sales
  REVENUE // Highest revenue generated (in cents)
  CONVERSION_RATE // Best conversion rate (conversions/clicks * 10000 for precision)
  NEW_CUSTOMERS // Most new customer acquisitions
}

enum CompetitionStatus {
  SCHEDULED // Not yet started
  ACTIVE // Currently running
  COMPLETED // Ended successfully
  CANCELLED // Cancelled by admin
}

// ===== ENTERPRISE AFFILIATE SYSTEM - ATTRIBUTION =====

// Multi-touch attribution tracking (HIPAA-safe: no names/medical data)
model AffiliateTouch {
  id        Int      @id @default(autoincrement())
  createdAt DateTime @default(now())
  clinicId  Int
  clinic    Clinic   @relation(fields: [clinicId], references: [id])

  // Visitor identification (HIPAA-safe: hashed/anonymized)
  visitorFingerprint String // Browser fingerprint hash
  cookieId           String? // First-party cookie ID
  ipAddressHash      String? // SHA-256 hashed IP for privacy
  userAgent          String?

  // Attribution data
  affiliateId Int
  affiliate   Affiliate @relation(fields: [affiliateId], references: [id])
  refCode     String

  // UTM tracking
  utmSource   String?
  utmMedium   String?
  utmCampaign String?
  utmContent  String?
  utmTerm     String?

  // Sub-ID tracking (custom tracking params)
  subId1 String?
  subId2 String?
  subId3 String?
  subId4 String?
  subId5 String?

  // Landing info
  landingPage String?
  referrerUrl String?

  // Touch type
  touchType TouchType @default(CLICK)

  // Conversion tracking
  convertedPatientId Int? // Set when this touch leads to conversion
  convertedAt        DateTime? // When conversion occurred

  @@index([clinicId, visitorFingerprint])
  @@index([clinicId, cookieId])
  @@index([affiliateId])
  @@index([createdAt])
  @@index([refCode])
}

enum TouchType {
  CLICK // Regular click
  IMPRESSION // View (for CPM tracking)
  POSTBACK // Server-to-server tracking
}

// Attribution configuration per clinic
model AffiliateAttributionConfig {
  id        Int      @id @default(autoincrement())
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  clinicId  Int      @unique
  clinic    Clinic   @relation(fields: [clinicId], references: [id])

  // Attribution model selection
  newPatientModel       AttributionModel @default(FIRST_CLICK)
  returningPatientModel AttributionModel @default(LAST_CLICK)

  // Cookie/window settings
  cookieWindowDays      Int @default(30)
  impressionWindowHours Int @default(24)

  // Fingerprinting
  enableFingerprinting Boolean @default(true)

  // Sub-ID tracking
  enableSubIds Boolean @default(true)
  maxSubIds    Int     @default(5)

  // Advanced settings
  crossDeviceEnabled     Boolean @default(false)
  viewThroughEnabled     Boolean @default(false)
  viewThroughWindowHours Int     @default(24)
}

enum AttributionModel {
  FIRST_CLICK // Credit to first referrer
  LAST_CLICK // Credit to most recent referrer
  LINEAR // Split evenly among all touches
  TIME_DECAY // More credit to recent touches (exponential decay)
  POSITION // 40% first, 40% last, 20% split among middle
}

// ===== ENTERPRISE AFFILIATE SYSTEM - TIERED COMMISSIONS =====

// Commission tiers within a plan
model AffiliateCommissionTier {
  id        Int                     @id @default(autoincrement())
  createdAt DateTime                @default(now())
  planId    Int
  plan      AffiliateCommissionPlan @relation(fields: [planId], references: [id], onDelete: Cascade)

  // Tier info
  name  String // "Bronze", "Silver", "Gold", "Platinum"
  level Int    @default(1) // 1, 2, 3, 4...

  // Requirements to reach this tier
  minConversions  Int  @default(0)
  minRevenueCents Int  @default(0)
  minActiveMonths Int? // Optional: months active

  // Override commission rate for this tier
  percentBps      Int? // Overrides plan rate
  flatAmountCents Int? // Overrides plan rate

  // Bonus for reaching tier
  bonusCents Int? // One-time bonus

  // Additional perks (JSON array of perk descriptions)
  perks Json?

  // Back-reference for affiliates at this tier
  affiliates Affiliate[]

  @@unique([planId, level])
  @@unique([planId, name])
  @@index([planId])
}

// Product-specific commission rates
model AffiliateProductRate {
  id        Int                     @id @default(autoincrement())
  createdAt DateTime                @default(now())
  planId    Int
  plan      AffiliateCommissionPlan @relation(fields: [planId], references: [id], onDelete: Cascade)

  // Product matching (supports SKU, category, or price range)
  productSku      String? // Exact SKU match
  productCategory String? // Category match
  minPriceCents   Int? // Min price for range
  maxPriceCents   Int? // Max price for range

  // Override rate for matching products
  percentBps      Int?
  flatAmountCents Int?

  // Priority (higher = checked first)
  priority Int @default(0)

  isActive Boolean @default(true)

  @@index([planId])
  @@index([productSku])
  @@index([productCategory])
}

// Time-limited promotional rates
model AffiliatePromotion {
  id        Int                     @id @default(autoincrement())
  createdAt DateTime                @default(now())
  updatedAt DateTime                @updatedAt
  planId    Int
  plan      AffiliateCommissionPlan @relation(fields: [planId], references: [id], onDelete: Cascade)

  // Promotion info
  name        String // "Summer 2026 Bonus"
  description String?

  // Time window
  startsAt DateTime
  endsAt   DateTime

  // Bonus rate during promotion (added on top of base)
  bonusPercentBps Int? // Additional % on top of base
  bonusFlatCents  Int? // Additional flat amount

  // Conditions
  minOrderCents Int? // Minimum order value
  maxUses       Int? // Max times this promotion can be used
  usesCount     Int  @default(0)

  // Targeting
  affiliateIds Json? // Specific affiliates (null = all)
  refCodes     Json? // Specific ref codes (null = all)

  isActive Boolean @default(true)

  @@index([planId, startsAt, endsAt])
  @@index([isActive])
}

// ===== ENTERPRISE AFFILIATE SYSTEM - PAYOUTS =====

// Affiliate payout methods
model AffiliatePayoutMethod {
  id          Int       @id @default(autoincrement())
  createdAt   DateTime  @default(now())
  updatedAt   DateTime  @updatedAt
  affiliateId Int
  affiliate   Affiliate @relation(fields: [affiliateId], references: [id])

  methodType PayoutMethodType
  isDefault  Boolean          @default(false)
  isVerified Boolean          @default(false)
  verifiedAt DateTime?

  // Stripe Connect
  stripeAccountId          String? // acct_xxx
  stripeAccountStatus      String? // pending, active, restricted
  stripeOnboardingComplete Boolean @default(false)

  // PayPal
  paypalEmail    String?
  paypalPayerId  String?
  paypalVerified Boolean @default(false)

  // Bank (for manual wire)
  bankName         String?
  bankAccountLast4 String? // Last 4 digits only
  bankRoutingLast4 String? // Last 4 digits only
  bankCountry      String?

  // Encrypted full details (for manual processing) - AES-256 encrypted JSON
  encryptedDetails String?
  encryptionKeyId  String? // KMS key ID used

  // Check mailing address
  mailingAddressLine1 String?
  mailingAddressLine2 String?
  mailingCity         String?
  mailingState        String?
  mailingZip          String?
  mailingCountry      String?

  metadata Json?

  @@unique([affiliateId, methodType])
  @@index([affiliateId])
}

enum PayoutMethodType {
  STRIPE_CONNECT // Direct deposit via Stripe
  PAYPAL // PayPal Payouts
  BANK_WIRE // Manual bank wire
  CHECK // Physical check
  MANUAL // Manual/other method
}

// Payout records
model AffiliatePayout {
  id          Int       @id @default(autoincrement())
  createdAt   DateTime  @default(now())
  updatedAt   DateTime  @updatedAt
  clinicId    Int
  clinic      Clinic    @relation(fields: [clinicId], references: [id])
  affiliateId Int
  affiliate   Affiliate @relation(fields: [affiliateId], references: [id])

  // Payout details
  amountCents    Int
  feeCents       Int              @default(0) // Processing fees
  netAmountCents Int // Amount after fees
  currency       String           @default("USD")
  methodType     PayoutMethodType

  // Status tracking
  status        AffiliatePayoutStatus @default(PENDING)
  scheduledAt   DateTime?
  processedAt   DateTime?
  completedAt   DateTime?
  failedAt      DateTime?
  failureReason String?
  failureCode   String? // Machine-readable error code

  // External references
  stripeTransferId String? // tr_xxx
  stripePayoutId   String? // po_xxx
  paypalBatchId    String?
  paypalPayoutId   String?
  checkNumber      String?
  wireReference    String?

  // Commission events included in this payout
  commissionEvents AffiliateCommissionEvent[]

  // Period covered
  periodStart DateTime?
  periodEnd   DateTime?

  // Audit
  processedBy Int? // Admin user ID who initiated
  approvedBy  Int? // Admin user ID who approved
  notes       String?

  @@index([clinicId])
  @@index([affiliateId])
  @@index([status])
  @@index([scheduledAt])
}

enum AffiliatePayoutStatus {
  PENDING // Awaiting processing
  SCHEDULED // Scheduled for future date
  AWAITING_APPROVAL // Needs admin approval
  PROCESSING // In progress
  COMPLETED // Successfully paid
  FAILED // Payment failed
  CANCELLED // Cancelled by admin
  ON_HOLD // Temporarily held
}

// Tax documents for compliance
model AffiliateTaxDocument {
  id          Int       @id @default(autoincrement())
  createdAt   DateTime  @default(now())
  updatedAt   DateTime  @updatedAt
  affiliateId Int
  affiliate   Affiliate @relation(fields: [affiliateId], references: [id])

  documentType TaxDocumentType
  taxYear      Int

  // Document storage (encrypted in S3)
  s3Key           String?
  s3Bucket        String?
  encryptionKeyId String? // KMS key ID

  // Status
  status          TaxDocumentStatus @default(PENDING)
  submittedAt     DateTime?
  verifiedAt      DateTime?
  verifiedBy      Int? // Admin user ID
  rejectedAt      DateTime?
  rejectionReason String?
  expiresAt       DateTime?

  // Extracted/validated data (masked for display)
  taxIdLast4        String? // Last 4 of SSN/EIN
  taxIdType         String? // SSN, EIN, ITIN
  legalName         String?
  businessName      String?
  taxClassification String? // Individual, LLC, Corporation, etc.
  address           String?

  // IRS TIN matching (optional)
  tinMatchStatus String? // matched, mismatched, pending
  tinMatchedAt   DateTime?

  @@unique([affiliateId, documentType, taxYear])
  @@index([affiliateId])
  @@index([status])
}

enum TaxDocumentType {
  W9 // US persons/entities
  W8BEN // Foreign individuals
  W8BENE // Foreign entities
}

enum TaxDocumentStatus {
  PENDING // Not yet submitted
  SUBMITTED // Submitted, awaiting review
  VERIFIED // Verified and valid
  REJECTED // Rejected, needs resubmission
  EXPIRED // Document expired
}

// ===== ENTERPRISE AFFILIATE SYSTEM - FRAUD DETECTION =====

// Fraud alerts for review
model AffiliateFraudAlert {
  id          Int       @id @default(autoincrement())
  createdAt   DateTime  @default(now())
  updatedAt   DateTime  @updatedAt
  clinicId    Int
  clinic      Clinic    @relation(fields: [clinicId], references: [id])
  affiliateId Int
  affiliate   Affiliate @relation(fields: [affiliateId], references: [id])

  alertType FraudAlertType
  severity  FraudSeverity  @default(MEDIUM)

  // Evidence
  description String
  evidence    Json // Detailed evidence data (IPs, patterns, etc.)

  // Related records
  commissionEventId Int?
  touchId           Int?

  // Risk scoring
  riskScore Int @default(50) // 0-100

  // Financial impact
  affectedAmountCents Int? // Commission at risk

  // Resolution
  status           FraudAlertStatus       @default(OPEN)
  resolvedAt       DateTime?
  resolvedBy       Int? // Admin user ID
  resolution       String? // Resolution notes
  resolutionAction FraudResolutionAction?

  @@index([clinicId])
  @@index([affiliateId])
  @@index([status])
  @@index([severity])
  @@index([createdAt])
}

enum FraudAlertType {
  SELF_REFERRAL // Affiliate referring themselves
  DUPLICATE_IP // Multiple conversions from same IP
  VELOCITY_SPIKE // Unusual conversion rate spike
  SUSPICIOUS_PATTERN // Detected anomaly in behavior
  GEO_MISMATCH // IP location doesn't match patient billing
  REFUND_ABUSE // High refund rate for affiliate's referrals
  COOKIE_STUFFING // Suspected cookie stuffing
  CLICK_FRAUD // Invalid click patterns
  DEVICE_FRAUD // Same device, multiple "new" conversions
  INCENTIVIZED_TRAFFIC // Suspected paid/incentivized signups
}

enum FraudSeverity {
  LOW // Minor concern, informational
  MEDIUM // Needs review
  HIGH // Likely fraud, hold commissions
  CRITICAL // Confirmed fraud, suspend affiliate
}

enum FraudAlertStatus {
  OPEN // New, not yet reviewed
  INVESTIGATING // Under investigation
  CONFIRMED_FRAUD // Fraud confirmed
  FALSE_POSITIVE // Not fraud
  DISMISSED // Dismissed without action
}

enum FraudResolutionAction {
  NO_ACTION // Alert dismissed
  WARNING_ISSUED // Warning sent to affiliate
  COMMISSION_REVERSED // Commission clawed back
  COMMISSIONS_HELD // Future commissions on hold
  AFFILIATE_SUSPENDED // Affiliate suspended
  AFFILIATE_TERMINATED // Affiliate terminated
}

// IP intelligence cache
model AffiliateIpIntel {
  id        Int      @id @default(autoincrement())
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  ipHash    String   @unique // SHA-256 hash of IP

  // Geolocation
  country     String?
  countryCode String?
  region      String?
  city        String?
  latitude    Float?
  longitude   Float?
  timezone    String?

  // ISP info
  isp          String?
  organization String?
  asn          String?

  // Risk indicators
  isProxy      Boolean @default(false)
  isVpn        Boolean @default(false)
  isTor        Boolean @default(false)
  isDatacenter Boolean @default(false)
  isBot        Boolean @default(false)
  isCrawler    Boolean @default(false)

  // Risk score (0-100, higher = riskier)
  riskScore  Int @default(0)
  fraudScore Int @default(0)

  // Provider used
  provider String? // "ipqualityscore", "maxmind", etc.

  // Cache expiry
  expiresAt DateTime

  @@index([ipHash])
  @@index([expiresAt])
}

// Fraud detection thresholds per clinic
model AffiliateFraudConfig {
  id        Int      @id @default(autoincrement())
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  clinicId  Int      @unique
  clinic    Clinic   @relation(fields: [clinicId], references: [id])

  // Enable/disable fraud checks
  enabled Boolean @default(true)

  // Velocity thresholds
  maxConversionsPerDay    Int   @default(50)
  maxConversionsPerHour   Int   @default(10)
  velocitySpikeMultiplier Float @default(3.0) // Alert if > 3x normal

  // IP thresholds
  maxConversionsPerIp Int     @default(3) // Per 30 days
  minIpRiskScore      Int     @default(75) // Alert if IP risk > 75
  blockProxyVpn       Boolean @default(false)
  blockDatacenter     Boolean @default(true)
  blockTor            Boolean @default(true)

  // Refund thresholds
  maxRefundRatePct   Int @default(20) // Alert if refund rate > 20%
  minRefundsForAlert Int @default(5) // Need at least 5 refunds to trigger

  // Geo settings
  enableGeoMismatchCheck Boolean @default(true)
  allowedCountries       Json? // null = all allowed

  // Self-referral
  enableSelfReferralCheck Boolean @default(true)

  // Auto-actions
  autoHoldOnHighRisk    Boolean @default(true)
  autoSuspendOnCritical Boolean @default(false)

  @@index([clinicId])
}

// =============================================================================
// LIFEFILE SHIPPING INTEGRATION
// =============================================================================

// Shipping status for prescription tracking at patient level
enum ShippingStatus {
  PENDING
  LABEL_CREATED
  SHIPPED
  IN_TRANSIT
  OUT_FOR_DELIVERY
  DELIVERED
  RETURNED
  EXCEPTION
  CANCELLED
}

// Patient-level shipping update records from Lifefile
// Stores prescription shipping/tracking info at the patient profile level
model PatientShippingUpdate {
  id        Int      @id @default(autoincrement())
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Multi-tenant isolation
  clinicId Int
  clinic   Clinic @relation(fields: [clinicId], references: [id])

  // Patient association
  patientId Int
  patient   Patient @relation(fields: [patientId], references: [id])

  // Optional order link (may be standalone update)
  orderId Int?
  order   Order? @relation(fields: [orderId], references: [id])

  // Tracking Information
  trackingNumber String
  carrier        String // UPS, FedEx, USPS, DHL, etc.
  trackingUrl    String?

  // Shipping Status
  status     ShippingStatus @default(SHIPPED)
  statusNote String?

  // Dates
  shippedAt         DateTime?
  estimatedDelivery DateTime?
  actualDelivery    DateTime?

  // Medication Info (for display on patient profile)
  medicationName     String?
  medicationStrength String?
  medicationQuantity String?
  medicationForm     String? // injection, tablet, etc.

  // External References
  lifefileOrderId String? // Lifefile's order ID
  externalRef     String? // Any other external reference
  brand           String? // Clinic brand name (Wellmedr, NewSelf, etc.)

  // Audit Trail
  rawPayload  Json? // Full webhook payload for debugging
  source      String    @default("lifefile") // lifefile, manual, pharmacy, etc.
  processedAt DateTime?

  @@index([clinicId, patientId])
  @@index([trackingNumber])
  @@index([lifefileOrderId])
  @@index([status])
}

// =============================================================================
// PRESCRIPTION REFILL QUEUE SYSTEM
// =============================================================================

// Status flow for prescription refills
enum RefillStatus {
  SCHEDULED // Future refill, not yet due
  PENDING_PAYMENT // Due, awaiting payment verification
  PENDING_ADMIN // Payment verified, awaiting admin approval
  APPROVED // Admin approved, ready for provider
  PENDING_PROVIDER // Queued for provider prescription
  PRESCRIBED // Provider submitted to Lifefile
  COMPLETED // Order fulfilled/delivered
  REJECTED // Admin rejected the refill
  CANCELLED // Patient or admin cancelled
  ON_HOLD // Temporarily paused (e.g., patient request)
}

// How payment was verified for the refill
enum PaymentVerificationMethod {
  STRIPE_AUTO // Auto-matched via Stripe payment
  MANUAL_VERIFIED // Admin manually verified payment
  EXTERNAL_REFERENCE // External payment method (Venmo, check, etc.)
  PAYMENT_SKIPPED // Admin skipped verification (for non-Stripe clinics)
}

// Tracks prescription refill schedules and approval workflow
// Flow: Patient subscription โ Scheduled refill โ Payment check โ Admin approval โ Provider queue โ Lifefile
model RefillQueue {
  id        Int      @id @default(autoincrement())
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Multi-tenant isolation
  clinicId Int
  clinic   Clinic @relation(fields: [clinicId], references: [id])

  // Patient association
  patientId Int
  patient   Patient @relation(fields: [patientId], references: [id])

  // Subscription link (optional - may be one-time refill)
  subscriptionId Int?
  subscription   Subscription? @relation(fields: [subscriptionId], references: [id])

  // Previous order reference (for refill continuity)
  lastOrderId Int?
  lastOrder   Order? @relation("RefillLastOrder", fields: [lastOrderId], references: [id])

  // Refill Schedule
  vialCount          Int       @default(1) // 1 = monthly, 3 = quarterly, 6 = semi-annual
  refillIntervalDays Int       @default(30) // 30, 90, or 180 days
  nextRefillDate     DateTime // When the refill becomes due
  lastRefillDate     DateTime? // When the previous refill was completed

  // Status Flow
  status RefillStatus @default(SCHEDULED)

  // Payment Verification
  paymentVerified   Boolean                    @default(false)
  paymentVerifiedAt DateTime?
  paymentVerifiedBy Int? // User ID who verified
  paymentMethod     PaymentVerificationMethod?
  paymentReference  String? // External payment reference (check #, Venmo ID, etc.)
  stripePaymentId   String? // Stripe payment intent ID if auto-matched
  invoiceId         Int? // Linked invoice if applicable
  invoice           Invoice?                   @relation(fields: [invoiceId], references: [id])

  // Admin Approval
  adminApproved   Boolean?
  adminApprovedAt DateTime?
  adminApprovedBy Int? // Admin user ID who approved/rejected
  adminNotes      String? // Notes from admin (reason for rejection, etc.)

  // Provider Queue
  providerQueuedAt DateTime? // When moved to provider queue
  prescribedAt     DateTime? // When provider submitted prescription
  prescribedBy     Int? // Provider user ID
  orderId          Int?      @unique // New order created for this refill
  order            Order?    @relation("RefillNewOrder", fields: [orderId], references: [id])

  // Patient Request Metadata
  requestedEarly Boolean @default(false) // Patient requested early refill
  patientNotes   String? // Notes from patient request

  // Medication Info (cached from subscription/last order for quick reference)
  medicationName     String?
  medicationStrength String?
  medicationForm     String?
  planName           String? // e.g., "Semaglutide 3 Month"

  @@index([clinicId, status])
  @@index([patientId])
  @@index([subscriptionId])
  @@index([nextRefillDate])
  @@index([status, nextRefillDate])
}

// ===== FINANCIAL ANALYTICS SYSTEM =====

// Type of saved report
enum ReportType {
  REVENUE
  PATIENTS
  PAYOUTS
  RECONCILIATION
  SUBSCRIPTIONS
  CUSTOM
}

// Granularity for time-based reports
enum ReportGranularity {
  DAILY
  WEEKLY
  MONTHLY
  QUARTERLY
  YEARLY
}

// Daily aggregated financial metrics for fast reporting
model FinancialMetrics {
  id       Int      @id @default(autoincrement())
  clinicId Int
  clinic   Clinic   @relation(fields: [clinicId], references: [id])
  date     DateTime @db.Date

  // Daily revenue aggregates (in cents)
  grossRevenue Int @default(0) // Total before fees/refunds
  netRevenue   Int @default(0) // After fees
  refunds      Int @default(0) // Total refunds
  fees         Int @default(0) // Stripe fees + platform fees

  // Subscription metrics (MRR in cents)
  newMrr         Int @default(0) // MRR from new subscriptions
  churnedMrr     Int @default(0) // MRR lost from cancellations
  expansionMrr   Int @default(0) // MRR from upgrades
  contractionMrr Int @default(0) // MRR lost from downgrades

  // Counts
  newSubscriptions      Int @default(0) // New subscriptions created
  canceledSubscriptions Int @default(0) // Subscriptions canceled
  newCustomers          Int @default(0) // New patients with payments
  activeSubscriptions   Int @default(0) // Total active at end of day

  // Payment metrics
  successfulPayments Int @default(0) // Count of successful payments
  failedPayments     Int @default(0) // Count of failed payments
  averageOrderValue  Int @default(0) // Average payment amount (cents)

  // Invoice metrics
  invoicesSent        Int @default(0)
  invoicesPaid        Int @default(0)
  invoicesOutstanding Int @default(0)
  outstandingAmount   Int @default(0) // Total outstanding (cents)

  // Dispute metrics
  disputesOpened Int @default(0)
  disputesWon    Int @default(0)
  disputesLost   Int @default(0)
  disputeAmount  Int @default(0) // Total disputed amount (cents)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@unique([clinicId, date])
  @@index([clinicId])
  @@index([date])
  @@index([clinicId, date])
}

// User-saved report configurations
model SavedReport {
  id        Int    @id @default(autoincrement())
  clinicId  Int
  clinic    Clinic @relation(fields: [clinicId], references: [id])
  createdBy Int
  user      User   @relation(fields: [createdBy], references: [id])

  // Report metadata
  name        String
  description String?
  type        ReportType
  isPublic    Boolean    @default(false) // Shared with all clinic users

  // Report configuration (metrics, filters, grouping, chart type)
  config Json

  // Scheduling
  isScheduled  Boolean   @default(false)
  schedule     String? // Cron expression (e.g., "0 9 * * 1" for Monday 9am)
  recipients   String[] // Email addresses for delivery
  lastRunAt    DateTime?
  nextRunAt    DateTime?
  lastRunError String? // Error message from last run if failed

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([clinicId])
  @@index([createdBy])
  @@index([type])
  @@index([isScheduled, nextRunAt])
}

// Export job tracking for async report generation
model ReportExport {
  id        Int    @id @default(autoincrement())
  clinicId  Int
  clinic    Clinic @relation(fields: [clinicId], references: [id])
  createdBy Int
  user      User   @relation(fields: [createdBy], references: [id])

  // Export configuration
  reportType     ReportType
  format         String // 'csv', 'excel', 'pdf'
  config         Json // Report configuration used
  dateRangeStart DateTime
  dateRangeEnd   DateTime

  // Status tracking
  status       String    @default("pending") // pending, processing, completed, failed
  progress     Int       @default(0) // 0-100 percentage
  startedAt    DateTime?
  completedAt  DateTime?
  errorMessage String?

  // File storage
  fileUrl   String? // S3 URL when completed
  fileName  String?
  fileSize  Int? // File size in bytes
  expiresAt DateTime? // When the download link expires

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([clinicId])
  @@index([status])
  @@index([createdBy])
}

// ===== PROVIDER ROUTING & COMPENSATION SYSTEM =====
// Enterprise feature for provider prescription routing, SOAP approval workflows,
// and per-script compensation tracking - configurable per clinic

enum RoutingStrategy {
  STATE_LICENSE_MATCH // Match provider's license state to patient's state
  ROUND_ROBIN // Rotate among available providers
  MANUAL_ASSIGNMENT // Admin manually assigns prescriptions
  PROVIDER_CHOICE // Providers self-select from shared queue
}

enum SoapApprovalMode {
  REQUIRED // Block prescribing without approved SOAP note
  ADVISORY // Show warning but allow provider to proceed
  DISABLED // No SOAP approval check
}

enum CompensationEventStatus {
  PENDING // Prescription completed, awaiting approval
  APPROVED // Approved for payout
  PAID // Payment processed
  VOIDED // Cancelled/voided (e.g., order cancelled)
}

enum CompensationType {
  FLAT_RATE // Fixed amount per prescription
  PERCENTAGE // Percentage of order/invoice total
  HYBRID // Both flat rate + percentage
}

// Clinic-level routing configuration
model ProviderRoutingConfig {
  id       Int    @id @default(autoincrement())
  clinicId Int    @unique
  clinic   Clinic @relation(fields: [clinicId], references: [id])

  // Feature enable flags - this is an optional feature per clinic
  routingEnabled      Boolean @default(false)
  compensationEnabled Boolean @default(false)

  // Routing strategy
  routingStrategy RoutingStrategy @default(PROVIDER_CHOICE)

  // SOAP note approval requirement
  soapApprovalMode SoapApprovalMode @default(ADVISORY)

  // Round-robin state tracking
  lastAssignedIndex      Int  @default(0)
  lastAssignedProviderId Int?

  // Auto-assignment settings
  autoAssignOnPayment Boolean @default(false) // Auto-assign when invoice paid

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

// Per-clinic, per-provider compensation rates
model ProviderCompensationPlan {
  id         Int      @id @default(autoincrement())
  clinicId   Int
  clinic     Clinic   @relation(fields: [clinicId], references: [id])
  providerId Int
  provider   Provider @relation(fields: [providerId], references: [id])

  // Compensation type (flat rate, percentage, or both)
  compensationType CompensationType @default(FLAT_RATE)

  // Compensation rates
  flatRatePerScript Int @default(500) // Amount in cents (e.g., 500 = $5.00)
  percentBps        Int @default(0) // Basis points (e.g., 1000 = 10%, 500 = 5%)

  // Effective dates for rate changes
  effectiveFrom DateTime  @default(now())
  effectiveTo   DateTime? // null = currently active
  isActive      Boolean   @default(true)

  // Audit
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  createdBy Int? // User who created/modified
  notes     String? // Admin notes about this rate

  // Relations
  compensationEvents ProviderCompensationEvent[]

  @@unique([clinicId, providerId]) // One active plan per provider per clinic
  @@index([clinicId])
  @@index([providerId])
  @@index([isActive])
}

// Per-prescription compensation event
model ProviderCompensationEvent {
  id         Int      @id @default(autoincrement())
  clinicId   Int
  clinic     Clinic   @relation(fields: [clinicId], references: [id])
  providerId Int
  provider   Provider @relation(fields: [providerId], references: [id])
  orderId    Int      @unique // One compensation event per order
  order      Order    @relation(fields: [orderId], references: [id])

  // Link to the plan used for calculation
  planId Int
  plan   ProviderCompensationPlan @relation(fields: [planId], references: [id])

  // Compensation details
  amountCents        Int // Total amount earned in cents
  prescriptionCount  Int   @default(1) // Number of prescriptions in order
  orderTotalCents    Int? // Order/invoice total used for percentage calculation
  calculationDetails Json? // Breakdown: { flatAmount, percentAmount, percentBps, etc. }

  // Status workflow
  status CompensationEventStatus @default(PENDING)

  // Payment tracking (for future payment integration)
  approvedAt      DateTime?
  approvedBy      Int? // User who approved
  paidAt          DateTime?
  payoutReference String? // External payment reference (Stripe, check #, etc.)
  payoutBatchId   String? // For batch payouts

  // Voiding
  voidedAt     DateTime?
  voidedBy     Int?
  voidedReason String?

  // Audit
  createdAt DateTime @default(now())
  metadata  Json? // Additional context (medication name, patient state, etc.)

  @@index([clinicId, providerId])
  @@index([clinicId, createdAt])
  @@index([providerId, status])
  @@index([status])
  @@index([createdAt])
}

// ============================================================================
// SOC 2 Policy Management
// ============================================================================

// Policy definitions for SOC 2 compliance
model Policy {
  id               Int      @id @default(autoincrement())
  policyId         String   @unique // e.g., "POL-001"
  title            String
  version          String // e.g., "1.0"
  effectiveDate    DateTime
  content          String // Full policy markdown
  contentHash      String // SHA-256 hash for tamper detection
  status           String   @default("draft") // draft, active, superseded
  requiresApproval Boolean  @default(true)
  approvalRoles    String[] // Roles required to approve
  createdAt        DateTime @default(now())
  updatedAt        DateTime @updatedAt

  // Relations
  PolicyApproval       PolicyApproval[]
  PolicyAcknowledgment PolicyAcknowledgment[]

  @@index([status])
  @@index([policyId])
}

// Executive policy approvals (digital signatures)
model PolicyApproval {
  id                    Int      @id @default(autoincrement())
  policyId              Int
  policy                Policy   @relation(fields: [policyId], references: [id])
  userId                Int
  user                  User     @relation(fields: [userId], references: [id])
  userEmail             String
  userName              String
  userRole              String
  approvalType          String // executive_approval, ciso_approval, compliance_approval
  ipAddress             String
  userAgent             String?
  contentHashAtApproval String // Hash when approved (tamper detection)
  signatureStatement    String // Legal statement agreed to
  approvedAt            DateTime @default(now())

  @@unique([policyId, userId, approvalType])
  @@index([policyId])
  @@index([userId])
  @@index([approvedAt])
}

// Employee policy acknowledgments
model PolicyAcknowledgment {
  id                          Int      @id @default(autoincrement())
  policyId                    Int
  policy                      Policy   @relation(fields: [policyId], references: [id])
  userId                      Int
  user                        User     @relation(fields: [userId], references: [id])
  userEmail                   String
  userName                    String
  userRole                    String
  clinicId                    Int?
  clinic                      Clinic?  @relation(fields: [clinicId], references: [id])
  ipAddress                   String
  userAgent                   String?
  contentHashAtAcknowledgment String // Hash when acknowledged
  acknowledgedAt              DateTime @default(now())

  @@unique([policyId, userId])
  @@index([policyId])
  @@index([userId])
  @@index([clinicId])
  @@index([acknowledgedAt])
}

// ============================================================================
// Telehealth Session Management
// ============================================================================

enum TelehealthSessionStatus {
  SCHEDULED
  WAITING
  IN_PROGRESS
  COMPLETED
  CANCELLED
  NO_SHOW
  TECHNICAL_ISSUES
}

model TelehealthSession {
  id            Int          @id @default(autoincrement())
  clinicId      Int?
  clinic        Clinic?      @relation(fields: [clinicId], references: [id])
  appointmentId Int?
  appointment   Appointment? @relation(fields: [appointmentId], references: [id])
  patientId     Int
  patient       Patient      @relation(fields: [patientId], references: [id])
  providerId    Int
  provider      Provider     @relation(fields: [providerId], references: [id])

  // Zoom Meeting Details
  meetingId   String  @unique
  meetingUuid String?
  joinUrl     String
  hostUrl     String?
  password    String?
  topic       String?

  // Scheduling
  scheduledAt    DateTime
  startedAt      DateTime?
  endedAt        DateTime?
  duration       Int       @default(30) // scheduled duration in minutes
  actualDuration Int? // actual duration in minutes

  // Status
  status   TelehealthSessionStatus @default(SCHEDULED)
  platform String                  @default("zoom") // zoom, teams, etc.

  // Recording (HIPAA: requires patient consent)
  recordingUrl      String?
  recordingPassword String?
  recordingDuration Int? // in seconds
  recordingSize     BigInt? // in bytes
  transcriptUrl     String?

  // Participant Tracking
  participantCount      Int?      @default(0)
  hostJoinedAt          DateTime?
  patientJoinedAt       DateTime?
  waitingRoomEnteredAt  DateTime?
  waitingRoomAdmittedAt DateTime?

  // Issues & Notes
  technicalIssues String?
  endReason       String?
  metadata        Json?

  // Audit
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relations
  participants TelehealthParticipant[]

  @@index([clinicId])
  @@index([appointmentId])
  @@index([patientId])
  @@index([providerId])
  @@index([status])
  @@index([scheduledAt])
}

model TelehealthParticipant {
  id                Int               @id @default(autoincrement())
  sessionId         Int
  session           TelehealthSession @relation(fields: [sessionId], references: [id], onDelete: Cascade)
  participantId     String? // External participant ID (from Zoom)
  name              String
  email             String?
  role              String            @default("participant") // host, cohost, participant
  joinedAt          DateTime
  leftAt            DateTime?
  duration          Int? // in seconds
  deviceType        String? // desktop, mobile, tablet
  ipAddress         String?
  location          String?
  connectionQuality String? // good, fair, poor
  audioEnabled      Boolean?          @default(true)
  videoEnabled      Boolean?          @default(true)
  screenShared      Boolean?          @default(false)
  createdAt         DateTime          @default(now())

  @@index([sessionId])
}

// ============================================================================
// Calendar Subscription & Export
// ============================================================================

model CalendarSubscription {
  id         Int      @id @default(autoincrement())
  providerId Int
  provider   Provider @relation(fields: [providerId], references: [id], onDelete: Cascade)
  clinicId   Int?
  clinic     Clinic?  @relation(fields: [clinicId], references: [id])
  token      String   @unique // Secure random token for URL
  name       String? // User-defined name for this subscription
  isActive   Boolean  @default(true)

  // Privacy Settings
  includePatientNames Boolean @default(false) // HIPAA: default to anonymized
  includeMeetingLinks Boolean @default(true)

  // Sync Configuration
  syncRangeDays Int @default(90) // Days to include in feed

  // Access Tracking
  lastAccessedAt DateTime?
  accessCount    Int       @default(0)

  // Audit
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([providerId])
}

// ============================================================================
// Address Validation Analytics
// ============================================================================

model AddressValidationLog {
  id Int @id @default(autoincrement())

  // Event Classification
  eventType   String // PARSE_SUCCESS, SMARTY_VALIDATED, etc.
  source      String // webhook, intake, manual, migration
  inputFormat String // combined_string, individual_fields, json

  // Context (optional - for debugging)
  clinicId  Int?
  patientId Int?

  // Validation Results
  wasStandardized  Boolean @default(false)
  confidence       Int? // 0-100 confidence score
  processingTimeMs Int? // Time taken to process

  // Error Tracking
  errorMessage String?

  // Truncated input preview (NOT full PHI)
  inputPreview String?

  // Audit
  createdAt DateTime @default(now())

  @@index([eventType])
  @@index([clinicId])
  @@index([source])
  @@index([createdAt])
}

// ============================================================================
// In-App Notification System
// ============================================================================

enum NotificationCategory {
  PRESCRIPTION // RX queue, prescription status changes
  PATIENT // New intake, patient updates
  ORDER // Shipping, delivery, tracking updates
  SYSTEM // Alerts, maintenance, system notifications
  APPOINTMENT // Scheduling, reminders
  MESSAGE // Internal messages, chat
  PAYMENT // Payment received, failed, refunds
  REFILL // Refill requests, approvals
}

enum NotificationPriority {
  LOW
  NORMAL
  HIGH
  URGENT
}

model Notification {
  id        Int      @id @default(autoincrement())
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Recipient
  userId   Int
  user     User    @relation(fields: [userId], references: [id], onDelete: Cascade)
  clinicId Int?
  clinic   Clinic? @relation(fields: [clinicId], references: [id])

  // Content
  category  NotificationCategory
  priority  NotificationPriority @default(NORMAL)
  title     String
  message   String
  actionUrl String? // Link to relevant page/resource
  metadata  Json? // Additional context (patientId, orderId, etc.)

  // Status
  isRead     Boolean   @default(false)
  readAt     DateTime?
  isArchived Boolean   @default(false)
  archivedAt DateTime?

  // Source tracking (for deduplication and audit)
  sourceType String? // 'webhook', 'system', 'user', 'cron'
  sourceId   String? // External reference (webhook ID, order ID, etc.)

  @@index([userId, isRead])
  @@index([userId, createdAt(sort: Desc)])
  @@index([userId, isArchived])
  @@index([clinicId, category])
  @@index([sourceType, sourceId])
}
